---
order: 10
title: "Лекция 9. MongoDB "
---

**Цель:** Научить студентов подключать облачную базу данных MongoDB Atlas к своему Node.js-приложению, проектировать схемы данных с помощью Mongoose и выполнять полные CRUD-операции для хранения и извлечения данных.

---

## Часть 1: Введение и Теоретическая Основа

### 1\.1. Вступление: от файлов к настоящей базе данных

**Преподаватель:** Добрый день, коллеги! На предыдущих восьми занятиях мы с вами прошли путь от простой HTML-страницы до полноценного веб-приложения с фронтендом и бэкендом.\
-- В **Модулях 1–3** мы создали структуру, стиль и поведение.\
-- В **Модуле 4** мы освоили два мощных инструмента: Git/GitHub и htmx.\
-- В **Модулях 5–6** мы погрузились в мир **React**, научившись создавать компонентные интерфейсы и работать с внешними API.\
-- В **Модулях 7–8** мы создали собственный сервер на **Node.js + Express** и построили профессиональное **REST API**, которое служит мостом между клиентом и сервером.

Но у нашего приложения был один серьёзный недостаток. В **Модуле 7** мы сохраняли данные в файл `feedback.json`, а в **Модуле 8** -- в памяти сервера. Это работало, но было **ненадёжно и не масштабируемо**. Данные терялись при перезапуске сервера, а работа с большими объёмами была бы очень медленной и неэффективной.

**Сегодня мы решим эту проблему раз и навсегда.**

Наша новая задача -- научиться хранить данные наших пользователей **надёжно, безопасно и эффективно**. Для этого мы перейдём от временных решений к настоящей, профессиональной базе данных.

И для этого мы выберем **MongoDB** -- одну из самых популярных NoSQL баз данных в мире.

**Почему MongoDB?**

-  Она хранит данные в формате **JSON-подобных документов**, что идеально сочетается с JavaScript и Node.js. Нам не нужно «переводить» данные из одного формата в другой.

-  Она имеет гибкую схему -- не нужно заранее определять строгую структуру таблицы, как в реляционных базах.

-  У неё есть отличная облачная платформа **MongoDB Atlas** с бесплатным тарифом, что позволяет нам начать работу без настройки собственного сервера.

После этого занятия ваши задачи, отзывы и пользователи наконец-то получат постоянное, надёжное и облачное хранилище.

---

### 1\.2. Что такое NoSQL и MongoDB?

**Преподаватель:** Давайте разберёмся, что же такое MongoDB и чем она отличается от классических баз данных.

В мире баз данных существует два основных подхода:

1. **Реляционные базы данных (SQL):** Например, MySQL, PostgreSQL.

   -  Данные хранятся в строгих **таблицах** со строками и столбцами.

   -  Отлично подходят для сложных запросов и транзакций, где важна целостность данных (например, банковские операции).

   -  Требуют заранее определённой схемы.

2. **Документные базы данных (NoSQL):** Например, MongoDB.

   -  Данные хранятся в гибких **документах**, которые очень похожи на обычные JSON-объекты.

   -  Отлично подходят для быстрой разработки, горизонтального масштабирования и работы с неструктурированными или быстро меняющимися данными.

   -  Схема может быть гибкой и меняться со временем.

**Структура MongoDB очень проста и интуитивна:**

-  **База данных (Database)** -- это контейнер верхнего уровня, который группирует все ваши данные для одного проекта.

-  **Коллекция (Collection)** -- это аналог таблицы в SQL. Это группа документов одного типа. Например, у нас будет коллекция `todos` для задач.

-  **Документ (Document)** -- это основная единица данных. Это BSON-объект (бинарная версия JSON) с полями и значениями. Каждый документ имеет уникальный идентификатор `_id`.

Пример документа задачи в MongoDB:

```json
{
  "_id": "507f1f77bcf86cd799439011",
  "title": "Выучить MongoDB",
  "completed": false,
  "createdAt": "2024-05-20T10:00:00Z"
}
```

Этот объект выглядит так же, как и JavaScript-объект, с которым мы работаем в нашем коде. Это и есть главная сила MongoDB.

---

### 1\.3. Mongoose и переменные окружения

**Преподаватель:** Работать с «голым» драйвером MongoDB возможно, но неудобно. Чтобы упростить себе жизнь, мы будем использовать библиотеку **Mongoose**.

**Mongoose** -- это **ODM (Object Data Modeling)** библиотека для MongoDB и Node.js. Она добавляет удобный слой абстракции над драйвером и предоставляет мощные инструменты:

-  **Схемы (Schema):** Позволяют определить структуру ваших документов, типы данных, обязательные поля и правила валидации. Это придаёт гибкости NoSQL-подходу необходимую строгость.

-  **Модели (Model):** Это конструкторы, созданные на основе схем. С их помощью мы легко выполняем операции CRUD (Create, Read, Update, Delete) с коллекциями.

-  **Middleware:** Позволяет выполнять код до или после определённых операций (например, хешировать пароль перед сохранением пользователя).

**Пример схемы для задачи:**

```javascript
const todoSchema = new mongoose.Schema({
  title: { type: String, required: true },
  completed: { type: Boolean, default: false }
});
```

**Важнейший аспект безопасности: переменные окружения.**

Строка подключения к вашей базе данных (`MONGO_URI`) содержит конфиденциальную информацию: логин, пароль и адрес кластера. **Никогда, ни при каких обстоятельствах не храните её в коде!** Если вы случайно зальёте код на GitHub, любой сможет получить доступ к вашей базе.

**Решение:** Используйте файл `.env` и библиотеку `dotenv`.

-  Файл `.env` хранится локально и **никогда не коммитится в Git** (его нужно добавить в `.gitignore`).

-  Библиотека `dotenv` автоматически загружает переменные из этого файла в объект `process.env` в вашем приложении.

Это стандартная и обязательная практика для любого профессионального проекта.

## Часть 2: Практическая Часть в WebStorm 

### 2\.1. Подготовка окружения 

**Преподаватель:** Отлично! Теория усвоена, теперь перейдём к практике. Первым делом нам нужно подготовить наше рабочее окружение и подключиться к облачной базе данных.

**Шаг 1: Регистрация в MongoDB Atlas**

1. Перейдите на официальный сайт: <https://www.mongodb.com/atlas>.

2. Нажмите **Try Free** и зарегистрируйте аккаунт (можно использовать Google-аккаунт для быстрой регистрации).

3. После входа вы попадёте в панель управления. Нажмите **Create a Cluster**.

4. Выберите бесплатный тариф **Shared (M0)** и нажмите **Create a Cluster**.

5. Дождитесь, пока кластер будет создан (это может занять несколько минут).

6. Настройте пользователя базы данных:

   -  Перейдите в раздел **Database Access**.

   -  Нажмите **Add New Database User**.

   -  Выберите **Password** как метод аутентификации.

   -  Придумайте имя пользователя (например, `admin`) и надёжный пароль. **Запомните их!**

   -  Выберите роль **Atlas admin** или **Read and write to any database**.

7. Настройте IP-адрес для доступа:

   -  Перейдите в раздел **Network Access**.

   -  Нажмите **Add IP Address**.

   -  Для разработки нажмите **Allow Access from Anywhere** (это добавит `0.0.0.0/0`). **В продакшене так делать нельзя!**

8. Скопируйте строку подключения:

   -  Вернитесь на главную страницу кластера.

   -  Нажмите **Connect** -> **Drivers**.

   -  Выберите драйвер **Node.js** и версию **4\.1 или новее**.

   -  Скопируйте строку подключения, заменив `<password>` на ваш пароль и `<dbname>` на имя вашей базы (например, `myApp`).

**Шаг 2: Настройка проекта в WebStorm**

1. Откройте ваш проект из **Модуля 8** (`feedback-server` или аналогичный) в WebStorm.

2. Установите необходимые зависимости в терминале:

   ```bash
   npm install mongoose dotenv
   ```

3. Создайте файл `.env` в корне проекта и вставьте туда вашу строку подключения:

   ```env
   MONGO_URI=mongodb+srv://admin:ваш_пароль@cluster0.xxxxx.mongodb.net/myApp?retryWrites=true&w=majority
   ```

4. **Важно:** Добавьте файл `.env` в `.gitignore`, чтобы случайно не залить его на GitHub!

5. В самом начале файла `server.js` подключите `dotenv`:

   ```javascript
   require('dotenv').config();
   // ... остальной код
   ```

Теперь у нас всё готово для подключения к базе данных.

---

### 2\.2. Практические задачи 

#### **Задача 1: Подключение к MongoDB и создание модели** 

Цель: настроить соединение с базой и определить структуру данных для задач.

1. **Подключение к базе (**`**server.js**`**):**

   -  Импортируйте Mongoose и подключитесь к базе:

      ```javascript
      const mongoose = require('mongoose');
      
      mongoose.connect(process.env.MONGO_URI)
        .then(() => console.log('✅ MongoDB подключена'))
        .catch(err => console.error('❌ Ошибка подключения:', err));
      ```

   -  Запустите сервер: `node server.js`. В консоли вы должны увидеть сообщение об успешном подключении.

2. **Создание модели (**`**models/Todo.js**`**):**

   -  Создайте папку `models` в корне проекта.

   -  В ней создайте файл `Todo.js`:

      ```javascript
      const mongoose = require('mongoose');
      
      // Определяем схему
      const todoSchema = new mongoose.Schema({
        title: { type: String, required: true },
        completed: { type: Boolean, default: false }
      });
      
      // Создаём и экспортируем модель
      module.exports = mongoose.model('Todo', todoSchema);
      ```

---

#### **Задача 2: Интеграция модели в REST API (15 минут)**

Цель: заменить работу с массивом в памяти на работу с MongoDB.

1. **Обновление маршрутов (**`**routes/todos.js**`**):**

   -  Импортируйте модель в начале файла:

      ```javascript
      const Todo = require('../models/Todo');
      ```

   -  Обновите все маршруты, обернув их в `async/await` и используя методы Mongoose:

      ```javascript
      // GET /api/todos
      router.get('/', async (req, res) => {
        try {
          const todos = await Todo.find();
          res.status(200).json(todos);
        } catch (err) {
          res.status(500).json({ error: 'Ошибка при получении задач' });
        }
      });
      
      // POST /api/todos
      router.post('/', async (req, res) => {
        try {
          const { title } = req.body;
          if (!title) {
            return res.status(400).json({ error: 'Текст задачи обязателен' });
          }
          const newTodo = await Todo.create({ title });
          res.status(201).json(newTodo);
        } catch (err) {
          res.status(500).json({ error: 'Ошибка при создании задачи' });
        }
      });
      
      // PUT /api/todos/:id
      router.put('/:id', async (req, res) => {
        try {
          const { completed } = req.body;
          const updatedTodo = await Todo.findByIdAndUpdate(
            req.params.id,
            { completed },
            { new: true } // Возвращает обновлённый документ
          );
          if (!updatedTodo) {
            return res.status(404).json({ error: 'Задача не найдена' });
          }
          res.status(200).json(updatedTodo);
        } catch (err) {
          res.status(500).json({ error: 'Ошибка при обновлении задачи' });
        }
      });
      
      // DELETE /api/todos/:id
      router.delete('/:id', async (req, res) => {
        try {
          const deletedTodo = await Todo.findByIdAndDelete(req.params.id);
          if (!deletedTodo) {
            return res.status(404).json({ error: 'Задача не найдена' });
          }
          res.status(204).send(); // No Content
        } catch (err) {
          res.status(500).json({ error: 'Ошибка при удалении задачи' });
        }
      });
      ```

2. **Тестирование:**

   -  Перезапустите сервер.

   -  Используйте **встроенный HTTP-клиент WebStorm** или **Postman** для отправки запросов.

   -  Добавьте несколько задач через `POST`.

   -  Перезапустите сервер и сделайте `GET`\-запрос. Задачи **не исчезли**! Они теперь хранятся в облаке.

**Преподаватель:** Поздравляю! Ваши данные теперь живут в профессиональной, облачной базе данных MongoDB. Это огромный шаг вперёд.

## Часть 3: Мини-проект, ДЗ и Заключение 

### 3.1. Мини-проект: «To-Do List с сохранением данных в MongoDB» 

**Преподаватель:** Отлично! Теперь, когда вы успешно подключили MongoDB и обновили ваш REST API, давайте соберём всё в единое, законченное приложение — **To-Do List с облачным хранилищем данных**.

Этот проект объединяет всё, что вы изучили за последние три модуля:
*   **React** из Модуля 5 для интерфейса.
*   **useEffect и формы** из Модуля 6 для взаимодействия с API.
*   **Express и REST** из Модулей 7–8 для серверной логики.
*   **MongoDB и Mongoose** из Модуля 9 для постоянного хранения данных.

**Требования к проекту:**
1.  **Бэкенд:** Полноценный REST API на Express, который использует Mongoose для работы с коллекцией `todos` в MongoDB Atlas.
2.  **Фронтенд:** React-приложение, которое полностью взаимодействует с этим API.
3.  **Функционал:**  
    *   При загрузке страницы список задач подгружается с сервера.  
    *   Все действия (добавление, удаление, отметка как выполненной) отправляют запросы на сервер и обновляют данные в облаке.  
    *   После перезапуска сервера или обновления страницы список задач **восстанавливается** в том же состоянии.

**План выполнения:**
1.  **Убедитесь в работоспособности API:** Используйте WebStorm HTTP Client, чтобы убедиться, что все CRUD-операции (`GET`, `POST`, `PUT`, `DELETE`) работают корректно и данные сохраняются в MongoDB.
2.  **Подключите React-фронтенд:** Убедитесь, что ваш `fetch`-запросы в React-компоненте указывают на правильный URL (`http://localhost:5000/api/todos`).
3.  **Протестируйте полный цикл:**  
    *   Добавьте 2-3 задачи через интерфейс.  
    *   Отметьте одну как выполненную.  
    *   Удалите другую.  
    *   Перезапустите сервер (`Ctrl+C`, `node server.js`).  
    *   Обновите страницу React-приложения. Список должен быть в том же состоянии, что и до перезапуска.

**Преподаватель:** Поздравляю! Ваши данные теперь живут в профессиональной, облачной базе данных. Это уже не учебный проект, а полноценное веб-приложение, готовое к дальнейшему развитию.

---

### 3.2. Домашнее задание 

**Преподаватель:** Чтобы закрепить материал и подготовиться к следующему модулю, выполните домашнее задание.

**Задание:** Улучшить мини-проект «To-Do List».

**Требования:**
1.  **Добавить поле `owner`:**  
    Обновите схему `Todo` в файле `models/Todo.js`, добавив новое поле:
    ```javascript
    const todoSchema = new mongoose.Schema({
      title: { type: String, required: true },
      completed: { type: Boolean, default: false },
      owner: { type: String, required: true } // Новое поле
    });
    ```
    Для простоты в этом задании вы можете передавать фиксированное значение (например, `"test-user"`) из фронтенда в каждом запросе.
2.  **Написать агрегатный запрос:**  
    Создайте новый маршрут в `routes/todos.js` для получения статистики:
    ```javascript
    router.get('/stats', async (req, res) => {
      try {
        const stats = await Todo.aggregate([
          {
            $group: {
              _id: null,
              total: { $sum: 1 },
              completed: { $sum: { $cond: ['$completed', 1, 0] } },
              active: { $sum: { $cond: ['$completed', 0, 1] } }
            }
          }
        ]);
        res.json(stats[0] || { total: 0, completed: 0, active: 0 });
      } catch (err) {
        res.status(500).json({ error: 'Ошибка при получении статистики' });
      }
    });
    ```
    Этот запрос использует мощный инструмент MongoDB — агрегацию — для подсчёта общего количества задач, а также количества выполненных и активных.

**Критерии оценки:**
*   **Оценка 5 (Отлично):** Задание выполнено полностью. Поле `owner` добавлено в схему и используется в API. Агрегатный запрос работает и возвращает корректную статистику.
*   **Оценка 4 (Хорошо):** Есть мелкие недочёты (например, поле добавлено, но агрегат не подключён к API).
*   **Оценка 3 (Удовлетворительно):** Реализована только базовая CRUD-функциональность.

**Срок сдачи:** [Укажите дату].

---

### 3.3. Контрольные вопросы и Заключение 

**Преподаватель:** Давайте подведём итоги и проверим, насколько хорошо вы усвоили материал. Я задам несколько вопросов.

**Контрольные вопросы:**

1.  **Какие основные типы данных поддерживает Mongoose?**  
    *Ответ:* `String`, `Number`, `Boolean`, `Date`, `Array`, `ObjectId`, `Buffer` и другие. Также можно определять вложенные объекты и схемы.

2.  **Как правильно обрабатывать ошибки подключения к базе данных?**  
    *Ответ:* Использовать блок `.catch()` при вызове `mongoose.connect()`. Это позволяет перехватить ошибку (например, неверный URI) и вывести её в консоль или отправить уведомление, не позволяя приложению упасть.

3.  **Что делает метод `findOneAndUpdate` и чем он отличается от `findByIdAndUpdate`?**  
    *Ответ:* Оба метода находят документ и обновляют его. `findByIdAndUpdate` ищет документ **только по его `_id`**. `findOneAndUpdate` позволяет искать документ по **любому другому полю** (например, `{ email: 'user@example.com' }`).

**Заключение:**

**Преподаватель:** Сегодня мы совершили один из самых важных шагов в нашем интенсиве. Мы перешли от временного хранения данных к профессиональному, надёжному и масштабируемому решению — **MongoDB в облаке**.

Теперь ваши приложения могут хранить данные пользователей, истории их действий и любую другую информацию, не боясь её потерять. Это фундамент для создания любого серьёзного веб-сервиса.

В следующем **Модуле 10** мы сделаем следующий логичный шаг: мы добавим **аутентификацию**. Наши данные будут не только в облаке, но и защищены от посторонних глаз. Каждый пользователь сможет видеть и редактировать только свои собственные задачи.

**Спасибо за внимание!** Удачи в выполнении домашнего задания. Помните: вы уже создали приложение, которое использует стек технологий, популярный в реальных коммерческих проектах!