---
order: 6
title: "Лекция 5. React: основы "
---

**Преподаватель:** \[Ваше Имя / Название Курса\]\
**Дата:** \[Дата проведения\]\
**Цель:** Познакомить студентов с библиотекой React как инструментом для создания компонентных пользовательских интерфейсов. Научить создавать функциональные компоненты, использовать JSX, управлять состоянием с помощью хука `useState`, передавать данные через пропсы и рендерить списки.

---

## Часть 1: Введение и Теоретическая Основа 

### 1\.1. Вступление: зачем нужен React? 

**Преподаватель:** Добрый день, коллеги! На предыдущих занятиях мы с вами прошли большой путь.\
-- В **Модуле 1** мы построили каркас сайта с помощью **HTML**.\
-- В **Модуле 2** мы оформили его, добавив стиль и красоту через **CSS**.\
-- В **Модуле 3** мы вдохнули в него жизнь, научив реагировать на действия пользователя с помощью **JavaScript**.\
-- В **Модуле 4** мы пошли двумя путями: сначала освоили **Git и GitHub** для управления кодом, а затем познакомились с **htmx** -- лёгким способом добавлять динамику без сложного JavaScript.

Но возникает закономерный вопрос: **а что делать, если наш проект становится большим, сложным и требует десятков, а то и сотен интерактивных элементов?**

В классическом подходе (даже с htmx) логика и DOM-манипуляции быстро запутываются. Представьте, что у вас есть список задач, фильтры, сортировка, форма редактирования -- и всё это должно работать синхронно. Обновление одного элемента может повлиять на десяток других, и отслеживать это вручную становится невозможно.

Именно для решения этой проблемы и была создана **React**.

**Что такое React?**\
React -- это **JavaScript-библиотека для построения пользовательских интерфейсов**, разработанная Facebook. Её главная идея -- **компонентный подход**.

**Компонентный подход** означает, что мы разбиваем наш интерфейс на независимые, переиспользуемые части -- **компоненты**. Каждый компонент -- это как мини-приложение со своей разметкой, логикой и стилями. Например:

-  Кнопка «Добавить задачу» -- это компонент.

-  Список задач -- это компонент.

-  Отдельная задача в списке -- это тоже компонент.

**Преимущества React:**

-  **Предсказуемость:** Вы описываете, *как должен выглядеть интерфейс* в зависимости от данных, а React сам заботится о том, *как обновить DOM*.

-  **Производительность:** React использует **виртуальный DOM** -- лёгкую копию реального DOM. Он сравнивает старую и новую версии и обновляет в браузере только то, что изменилось.

-  **Масштабируемость:** Компоненты легко комбинировать и вкладывать друг в друга, что позволяет строить очень сложные приложения из простых кирпичиков.

Сегодня мы сделаем первый шаг в этом направлении и научимся создавать свои первые компоненты на React.

---

### 1\.2. Основные концепции: JSX и компоненты 

**Преподаватель:** Чтобы писать на React, нам нужно познакомиться с двумя ключевыми понятиями: **компонентами** и **JSX**.

**Что такое компонент?**\
Компонент -- это **самостоятельная единица пользовательского интерфейса**. В современном React мы в основном используем **функциональные компоненты**. Это обычная JavaScript-функция, которая возвращает разметку.

Пример простейшего компонента:

```jsx
function Welcome() {
  return <h1>Добро пожаловать в мир React!</h1>;
}
```

Эта функция ничего не принимает и всегда возвращает один и тот же заголовок. Но компоненты могут быть и динамичными.

**Что такое JSX?**\
JSX -- это **синтаксический сахар**, который позволяет нам писать HTML-подобную разметку прямо внутри JavaScript-кода. Это выглядит привычно, но на самом деле это не HTML, а синтаксис, который транспилируется в вызовы функции `React.createElement()`.

**Правила JSX:**

1. **Один корневой элемент:** Функция компонента должна возвращать только один корневой элемент. Если вам нужно вернуть несколько элементов, оберните их в `<div>` или в специальный компонент `<React.Fragment>` (или его короткую запись `<>...</>`).

   ```jsx
   // Правильно
   return (
     <>
       <h1>Заголовок</h1>
       <p>Абзац</p>
     </>
   );
   ```

2. **camelCase для атрибутов:** В JSX все атрибуты пишутся в стиле camelCase. Например, `class` становится `className`, а `for` (в `<label>`) становится `htmlFor`.

   ```jsx
   // В HTML
   <div class="container" for="input">...</div>
   // В JSX
   <div className="container" htmlFor="input">...</div>
   ```

3. **JavaScript-выражения в фигурных скобках:** Чтобы вставить значение переменной или результат выражения в разметку, используйте фигурные скобки `{}`.

   ```jsx
   function Greeting({ name }) {
     return <h1>Привет, {name.toUpperCase()}!</h1>;
   }
   ```

JSX делает код React очень читаемым и декларативным. Вы описываете, *каким должен быть интерфейс*, а не *как его построить шаг за шагом*.

---

### 1\.3. Управление данными: пропсы и состояние 

**Преподаватель:** Теперь, когда мы знаем, как создавать компоненты, давайте научимся управлять данными внутри них. В React есть два основных источника данных: **пропсы (props)** и **состояние (state)**.

**Пропсы (Props):**\
Пропсы -- это **входные данные** для компонента. Они передаются от родительского компонента к дочернему, как атрибуты в HTML. Пропсы **неизменяемы** -- дочерний компонент не может их изменить, он может только их читать.

Пример передачи пропсов:

```jsx
// Родительский компонент
function App() {
  return <Welcome name="Алиса" />;
}

// Дочерний компонент
function Welcome(props) {
  return <h1>Привет, {props.name}!</h1>;
}
```

Здесь `name="Алиса"` -- это пропс. Внутри компонента `Welcome` он доступен через объект `props`.

**Состояние (State):**\
Состояние -- это **данные, которые могут меняться со временем** и влияют на то, как компонент рендерится. Например, значение счётчика, список задач, статус загрузки.

Для управления состоянием в функциональных компонентах используется **хук** `**useState**`. Хуки -- это специальные функции, которые позволяют «подключать» возможности React к функциональным компонентам.

Как работает `useState`:

```jsx
import { useState } from 'react';

function Counter() {
  // useState возвращает массив из двух элементов:
  // 1. Текущее значение состояния (count)
  // 2. Функцию для его обновления (setCount)
  const [count, setCount] = useState(0); // 0 — начальное значение

  return (
    <button onClick={() => setCount(count + 1)}>
      Нажато {count} раз
    </button>
  );
}
```

Когда вы вызываете `setCount`, React запланирует повторный рендер компонента с новым значением `count`.

**Главное различие:**

-  Используйте **пропсы**, когда данные поступают **извне** (от родителя).

-  Используйте **состояние**, когда компонент **сам управляет** этими данными (например, пользовательский ввод).

## Часть 2: Практическая Часть в WebStorm 

### 2\.1. Подготовка рабочего окружения 

**Преподаватель:** Отлично! Теория -- это важно, но настоящая магия React раскрывается на практике. Давайте настроим нашу среду разработки в WebStorm и создадим наше первое React-приложение.

**Шаг 1: Создание проекта с помощью Create React App**

Create React App (CRA) -- это официальный инструмент от команды React для быстрого старта проекта. Он автоматически настраивает всё необходимое: Babel для транспиляции JSX, Webpack для сборки, ESLint для проверки кода и многое другое.

1. Откройте **встроенный терминал** в WebStorm. Сочетание клавиш: `Alt + F12`.

2. Убедитесь, что вы находитесь в той папке, где хотите создать проект (например, в своей рабочей директории).

3. Выполните следующую команду:

   ```bash
   npx create-react-app my-todo-app
   ```

   Эта команда может занять несколько минут, так как она скачивает и устанавливает все необходимые зависимости.

**Шаг 2: Открытие проекта в WebStorm**

1. После завершения установки в терминале появится сообщение об успехе.

2. В WebStorm перейдите в меню: `File` -> `Open`.

3. Найдите папку `my-todo-app`, которую только что создала команда `npx`, и выберите её.

4. WebStorm откроет новый проект. Вы увидите знакомую структуру папок.

**Шаг 3: Запуск проекта**

1. Убедитесь, что вы находитесь в корне нового проекта в терминале (`my-todo-app`).

2. Выполните команду:

   ```bash
   npm start
   ```

3. WebStorm автоматически предложит открыть приложение в браузере. Нажмите на ссылку или перейдите вручную по адресу `http://localhost:3000`.

4. Вы увидите стандартную стартовую страницу React с логотипом и надписью "Edit `src/App.js` and save to reload". Это означает, что всё работает!

**Шаг 4: Структура проекта**

Давайте кратко познакомимся с ключевыми файлами:

-  `public/index.html`: Это основной HTML-файл. Обратите внимание, что в нём есть только один `<div id="root"></div>`. Всё остальное (весь наш React-код) будет "вмонтировано" в этот элемент.

-  `src/index.js`: Это **точка входа** в наше приложение. Именно здесь React подключается к DOM через `ReactDOM.createRoot(document.getElementById('root'))`.

-  `src/App.js`: Это **главный компонент** нашего приложения. Именно его мы будем редактировать в первую очередь. Он экспортируется и импортируется в `index.js`.

Теперь у нас всё готово для написания кода!

---

### 2\.2. Практические задачи 

**Преподаватель:** Приступим к решению практических задач. Мы будем редактировать файл `src/App.js`. Удалите из него весь стандартный код, оставив только базовую структуру компонента.

#### **Задача 1: Счётчик с кнопками + и –** 

Цель: научиться использовать хук `useState` для управления состоянием.

1. Откройте файл `src/App.js`.

2. Удалите всё содержимое внутри компонента `App` и импортируйте `useState`:

   ```jsx
   import { useState } from 'react';
   import './App.css'; // Можно оставить для стилей
   
   function App() {
     // Ваш код будет здесь
     return (
       // Ваша разметка будет здесь
     );
   }
   
   export default App;
   ```

3. Объявите состояние для счётчика:

   ```jsx
   function App() {
     const [count, setCount] = useState(0);
     // ...
   }
   ```

   Здесь `count` -- текущее значение счётчика, а `setCount` -- функция для его изменения. Начальное значение -- `0`.

4. Создайте функции для увеличения и уменьшения счётчика:

   ```jsx
   function App() {
     const [count, setCount] = useState(0);
   
     const increment = () => {
       setCount(count + 1);
     };
   
     const decrement = () => {
       setCount(count - 1);
     };
   
     return (
       // ...
     );
   }
   ```

5. Верните JSX-разметку с отображением счётчика и двумя кнопками:

   ```jsx
   return (
     <div className="App">
       <h1>Счётчик: {count}</h1>
       <button onClick={increment}>+</button>
       <button onClick={decrement}>-</button>
     </div>
   );
   ```

6. **Протестируйте:** Сохраните файл. Браузер автоматически обновится (благодаря Hot Module Replacement). Нажмите на кнопки -- значение счётчика должно изменяться без перезагрузки страницы. Это и есть реактивность React!

---

#### **Задача 2: Список заметок** 

Цель: научиться рендерить списки и управлять массивами в состоянии.

1. В том же файле `App.js`, ниже состояния счётчика, добавьте новое состояние для заметок:

   ```jsx
   const [notes, setNotes] = useState([]);
   ```

   Начальное значение -- пустой массив.

2. Создайте состояние и функцию для управления текстом в поле ввода:

   ```jsx
   const [noteText, setNoteText] = useState('');
   ```

3. Создайте функцию `addNote`, которая будет добавлять новую заметку в массив:

   ```jsx
   const addNote = () => {
     if (noteText.trim() !== '') {
       setNotes([...notes, noteText]); // Создаём новый массив с новой заметкой
       setNoteText(''); // Очищаем поле ввода
     }
   };
   ```

   **Важно:** В React состояние **неизменяемо**. Мы не можем написать `notes.push(...)`. Вместо этого мы создаём **новый массив** с помощью оператора расширения (`...`).

4. Создайте форму и список в JSX:

   ```jsx
   return (
     <div className="App">
       {/* ... предыдущий код со счётчиком ... */}
   
       <h2>Список заметок</h2>
       <form onSubmit={(e) => { e.preventDefault(); addNote(); }}>
         <input
           type="text"
           value={noteText}
           onChange={(e) => setNoteText(e.target.value)}
           placeholder="Введите заметку"
         />
         <button type="submit">Добавить</button>
       </form>
   
       <ul>
         {notes.map((note, index) => (
           <li key={index}>{note}</li>
         ))}
       </ul>
     </div>
   );
   ```

   -  `value={noteText}` и `onChange` делают поле ввода **управляемым** (controlled component).

   -  `onSubmit` предотвращает стандартную перезагрузку страницы при отправке формы.

   -  В `.map()` мы рендерим каждый элемент массива. **Обязательно** добавляем уникальный `key` (в нашем случае -- индекс). Это помогает React эффективно обновлять список.

5. **Протестируйте:** Введите текст в поле и нажмите "Добавить". Новая заметка должна появиться в списке. Попробуйте добавить несколько заметок.

**Преподаватель:** Поздравляю! Вы только что создали два полноценных интерактивных компонента на React. Вы управляли состоянием, работали с событиями и рендером списков -- это фундамент, на котором строятся все React-приложения.

## Часть 3: Мини-проект, ДЗ и Заключение 

### 3\.1. Мини-проект: «To-Do List без бэкенда» 

**Преподаватель:** Отлично! Теперь, когда вы освоили основы, давайте соберём всё вместе в одном небольшом, но очень полезном проекте -- **To-Do List** (список задач). Это классическое задание для изучения React, и оно идеально подходит для закрепления пропсов, состояния и рендеринга списков.

**Цель проекта:** Создать интерфейс, в котором можно:

-  Добавлять новые задачи через форму.

-  Отмечать задачи как выполненные (через чекбокс).

-  Удалять задачи.

**Требования к реализации:**

1. Все данные должны храниться **локально в состоянии** компонента `App`.

2. Каждая задача должна быть объектом с тремя свойствами:

   -  `id`: уникальный идентификатор (можно использовать `Date.now()` для простоты).

   -  `text`: текст задачи.

   -  `isCompleted`: булево значение (`true`/`false`), указывающее, выполнена ли задача.

3. Список задач должен отображаться как список элементов `<li>`, каждый из которых содержит чекбокс и кнопку удаления.

**План выполнения в** `**src/App.js**`**:**

1. **Создайте состояние для задач:**

   ```jsx
   const [todos, setTodos] = useState([]);
   ```

2. **Создайте состояние и функцию для формы:**

   ```jsx
   const [inputValue, setInputValue] = useState('');
   
   const handleAddTodo = (e) => {
     e.preventDefault();
     if (inputValue.trim() !== '') {
       setTodos([
         ...todos,
         { id: Date.now(), text: inputValue, isCompleted: false }
       ]);
       setInputValue('');
     }
   };
   ```

3. **Создайте функцию для переключения статуса задачи:**

   ```jsx
   const toggleTodo = (id) => {
     setTodos(todos.map(todo =>
       todo.id === id ? { ...todo, isCompleted: !todo.isCompleted } : todo
     ));
   };
   ```

4. **Создайте функцию для удаления задачи:**

   ```jsx
   const deleteTodo = (id) => {
     setTodos(todos.filter(todo => todo.id !== id));
   };
   ```

5. **Соберите всё в JSX:**

   ```jsx
   return (
     <div className="App">
       <h1>Мой To-Do List</h1>
       <form onSubmit={handleAddTodo}>
         <input
           type="text"
           value={inputValue}
           onChange={(e) => setInputValue(e.target.value)}
           placeholder="Введите задачу"
         />
         <button type="submit">Добавить</button>
       </form>
   
       <ul>
         {todos.map(todo => (
           <li key={todo.id} style={{ textDecoration: todo.isCompleted ? 'line-through' : 'none' }}>
             <input
               type="checkbox"
               checked={todo.isCompleted}
               onChange={() => toggleTodo(todo.id)}
             />
             {todo.text}
             <button onClick={() => deleteTodo(todo.id)}>Удалить</button>
           </li>
         ))}
       </ul>
     </div>
   );
   ```

**Преподаватель:** Сохраните файл и протестируйте приложение. Вы должны иметь возможность добавлять задачи, отмечать их как выполненные (они будут зачёркнуты) и удалять их. Это полноценное, работающее React-приложение!

---

### 3\.2. Домашнее задание 

**Преподаватель:** Чтобы закрепить материал и подготовиться к следующему модулю, выполните домашнее задание.

**Задание:** Улучшить мини-проект To-Do List.

**Требования:**

1. **Подключить ESLint и Prettier:** Это инструменты для автоматического форматирования кода и поиска ошибок. Они помогут вам писать чистый и единообразный код. Инструкции по настройке будут в материалах к занятию.

2. **Разбить приложение на компоненты:** Ваш файл `App.js` сейчас содержит всю логику. Разбейте его на 3–4 логических компонента:

   -  `App`: главный компонент, управляющий состоянием.

   -  `TodoForm`: компонент формы для добавления задач.

   -  `TodoList`: компонент, который рендерит список.

   -  `TodoItem`: компонент для отдельной задачи.

3. **Передавать данные и функции через пропсы:** Убедитесь, что `App` передаёт необходимые данные (`todos`) и функции (`handleAddTodo`, `toggleTodo`, `deleteTodo`) своим дочерним компонентам.

**Критерии оценки:**

-  **Оценка 5 (Отлично):** Задание выполнено полностью. Все компоненты вынесены, данные передаются через пропсы, ESLint/Prettier подключены и работают.

-  **Оценка 4 (Хорошо):** Есть мелкие ошибки (например, не все компоненты вынесены, или пропсы передаются неоптимально).

-  **Оценка 3 (Удовлетворительно):** Реализована только базовая функциональность без разбиения на компоненты.

**Срок сдачи:** \[Укажите дату\].

---

### 3\.3. Контрольные вопросы и Заключение 

**Преподаватель:** Давайте подведём итоги и проверим, насколько хорошо вы усвоили материал. Я задам несколько вопросов.

**Контрольные вопросы:**

1. **Для чего нужны ключи (**`**key**`**) при рендере списков в React?**\
   *Ответ:* Ключи помогают React идентифицировать, какие элементы были добавлены, изменены или удалены. Это позволяет React эффективно обновлять DOM, не перерисовывая весь список целиком.

2. **Что следует хранить в состоянии (**`**state**`**), а что можно вычислять на лету?**\
   *Ответ:* В состоянии следует хранить только минимальный набор данных, которые могут меняться со временем. Всё, что можно вычислить из состояния или пропсов (например, отфильтрованный список), лучше вычислять на лету, чтобы избежать избыточности и ошибок.

3. **Как передать данные из родительского компонента в дочерний?**\
   *Ответ:* Через **пропсы (props)**. Родительский компонент передаёт данные как атрибуты при вызове дочернего компонента, а дочерний получает их через свой первый аргумент (обычно называемый `props`).

**Заключение:**

**Преподаватель:** Сегодня мы совершили огромный шаг вперёд. Мы познакомились с **React** -- одной из самых популярных и мощных библиотек для создания пользовательских интерфейсов. Вы освоили фундаментальные концепции: компоненты, JSX, пропсы и состояние. Вы создали своё первое интерактивное React-приложение, и это только начало!

React открывает перед вами двери в мир современной веб-разработки. В следующем **Модуле 6** мы изучим **хук** `**useEffect**`, научимся работать с **формами** и делать запросы к **внешним API**, чтобы наши приложения могли общаться с реальным миром.

**Спасибо за внимание!** Удачи в выполнении домашнего задания. Не забывайте: каждая строка кода приближает вас к созданию собственного, полноценного веб-приложения!