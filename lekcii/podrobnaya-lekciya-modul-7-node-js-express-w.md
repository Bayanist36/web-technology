---
order: 8
title: Лекция 7. Node.js + Express (WebStorm-версия)
---

**Цель:** Познакомить студентов с серверной разработкой на JavaScript с помощью Node.js и фреймворка Express. Научить создавать веб-сервер, обрабатывать HTTP-запросы (GET/POST), отдавать статические файлы и сохранять данные в файловой системе.

---

## Часть 1: Введение и Теоретическая Основа 

### 1\.1. Вступление: зачем нужен бэкенд? 

**Преподаватель:** Добрый день, коллеги! На предыдущих шести занятиях мы с вами полностью погрузились в мир **фронтенда**.\
-- В **Модулях 1–2** мы создали структуру и стиль веб-страницы.\
-- В **Модуле 3** мы добавили поведение с помощью JavaScript.\
-- В **Модуле 4** мы освоили два мощных инструмента: сначала **Git и GitHub** для управления кодом, а затем **htmx** для динамики без сложного JS.\
-- В **Модулях 5–6** мы сделали огромный шаг вперёд, освоив **React**, научившись создавать компонентные интерфейсы, управлять состоянием, работать с формами и даже получать данные из внешних API.

Но все эти приложения были **глухими и слепыми**. Они не могли:

-  Сохранить ваши задачи из To-Do List **надолго** (всё исчезало при перезагрузке).

-  Отправить вашу форму обратной связи **реальному получателю**.

-  Позволить другим пользователям видеть ваши данные.

**Сегодня мы откроем дверь в другой мир -- мир бэкенда.**

Наша новая задача -- научиться создавать **сервер**, программу, которая работает на удалённом компьютере 24/7, принимает запросы от браузеров и умеет **хранить и обрабатывать данные**.

И для этого мы будем использовать **JavaScript** -- тот самый язык, который вы уже знаете! Благодаря **Node.js**, JavaScript вышел за пределы браузера и стал полноценным языком для серверной разработки.

---

### 1\.2. Что такое Node.js и Express? 

**Преподаватель:** Давайте разберёмся, что же такое Node.js и зачем нам нужен Express.

**Node.js** -- это **среда выполнения JavaScript на стороне сервера**. Под капотом у неё стоит тот же самый движок **V8**, что и в Google Chrome. Это позволяет запускать JS-код не в браузере, а прямо в терминале вашего компьютера или на сервере.

Главное преимущество Node.js -- его **событийная, неблокирующая модель**. Представьте ресторан:

-  В традиционной модели (блокирующей) один официант обслуживает одного клиента от начала и до конца, прежде чем перейти к следующему.

-  В модели Node.js (неблокирующей) официант принимает заказ у клиента и сразу же идёт к следующему, не дожидаясь, пока кухня приготовит еду для первого. Когда еда готова, он получает сигнал и относит её клиенту.

Это делает Node.js невероятно эффективным для задач, связанных с вводом-выводом (I/O), таких как работа с сетью, файлами или базами данных.

Однако писать сервер на «голом» Node.js сложно, так как его встроенный модуль `http` очень низкоуровневый.

**Express.js** -- это **минималистичный фреймворк** поверх Node.js, который решает эту проблему. Он предоставляет простой и элегантный API для:

-  Создания веб-сервера.

-  Определения маршрутов (routes) -- правил, по которым обрабатываются запросы.

-  Подключения промежуточного ПО (middleware).

-  Отдачи статических файлов.

Express -- это стандарт де-факто для Node.js-бэкенда, и именно его мы будем использовать сегодня.

**Ключевые понятия:**

-  `**req**` **(request)** -- объект, который содержит всю информацию о входящем запросе: URL, HTTP-метод (`GET`, `POST`), заголовки, тело запроса и т.д.

-  `**res**` **(response)** -- объект, с помощью которого мы формируем и отправляем ответ клиенту (браузеру).

-  **Маршрут (route)** -- это правило, которое связывает HTTP-метод и URL-путь с функцией-обработчиком. Например: `POST /submit` -> "сохранить данные в файл".

---

### 1\.3. Middleware и обработка ошибок 

**Преподаватель:** Теперь познакомимся с двумя мощными концепциями Express: **middleware** и **обработкой ошибок**.

**Middleware (промежуточное ПО)** -- это функции, которые выполняются **последовательно** для каждого входящего запроса, до того как он достигнет конечного обработчика маршрута.

Каждая middleware-функция имеет доступ к трём аргументам:

-  `req` -- объект запроса.

-  `res` -- объект ответа.

-  `next` -- функция, которая передаёт управление **следующей** middleware в цепочке.

Если middleware не вызывает `next()`, цепочка прерывается, и запрос «умирает».

**Примеры встроенных middleware в Express:**

-  `express.json()` -- автоматически парсит тело запроса, если оно в формате JSON, и помещает результат в `req.body`.

-  `express.urlencoded({ extended: true })` -- парсит тело запроса из HTML-формы и помещает данные в `req.body`.

-  `express.static('public')` -- отдаёт статические файлы (HTML, CSS, JS, изображения) из указанной папки.

**Обработка ошибок:**\
Express позволяет создать **глобальный обработчик ошибок**. Это специальная middleware-функция, которая вызывается, если в любом обработчике маршрута возникает ошибка (например, через `throw` или `next(err)`).

Она отличается от обычной middleware тем, что имеет **четыре параметра**:

```javascript
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Что-то пошло не так!');
});
```

Это позволяет централизованно логировать ошибки и отправлять пользователю понятное сообщение, не показывая внутренние детали сервера.

## Часть 2: Практическая Часть в WebStorm 

### 2\.1. Подготовка рабочего окружения 

**Преподаватель:** Отлично! Теория усвоена, теперь перейдём к практике. Для работы с Node.js и Express нам понадобится правильно настроить среду в WebStorm.

**Шаг 1: Установка Node.js**

Если вы ещё не установили Node.js, сделайте это сейчас:

1. Перейдите на официальный сайт: <https://nodejs.org>.

2. Скачайте и установите **LTS-версию** (она самая стабильная).

3. Проверьте установку в терминале WebStorm (`Alt + F12`):

   ```bash
   node -v
   npm -v
   ```

   Вы должны увидеть версии, например: `v20.12.0` и `10.5.0`.

**Шаг 2: Создание проекта в WebStorm**

1. В WebStorm создайте новую папку для сервера, например, `feedback-server`.

2. Откройте эту папку как проект: `File` -> `Open`.

3. Инициализируйте npm-проект. В терминале выполните:

   ```bash
   npm init -y
   ```

   Эта команда создаст файл `package.json`, который будет хранить информацию о вашем проекте и его зависимостях.

4. Установите Express:

   ```bash
   npm install express
   ```

   Теперь в папке `node_modules` появится Express, а в `package.json` -- запись о нём.

Теперь у нас всё готово для написания кода сервера.

---

### 2\.2. Практические задачи 

#### **Задача 1: Простейший сервер «Привет, мир!»** 

Цель: научиться создавать базовый сервер на Express.

1. В корне проекта создайте файл `server.js`.

2. Импортируйте Express и создайте приложение:

   ```javascript
   // server.js
   const express = require('express');
   const app = express();
   const PORT = 3000;
   ```

3. Определите маршрут для главной страницы:

   ```javascript
   app.get('/', (req, res) => {
     res.send('Привет, мир!');
   });
   ```

   Здесь `app.get` создаёт маршрут для HTTP-метода `GET` по пути `/`. Функция-обработчик принимает `req` (запрос) и `res` (ответ). Мы отправляем простой текст.

4. Запустите сервер:

   ```javascript
   app.listen(PORT, () => {
     console.log(`Сервер запущен на http://localhost:${PORT}`);
   });
   ```

5. **Запустите сервер:** В терминале выполните:

   ```bash
   node server.js
   ```

6. **Протестируйте:** Откройте в браузере `http://localhost:3000`. Вы должны увидеть надпись «Привет, мир!». Поздравляю, ваш первый сервер работает!

---

#### **Задача 2: Отдача статической формы** 

Цель: научиться отдавать HTML-файлы и обрабатывать форму.

1. Создайте папку `public` в корне проекта. Express будет отдавать из неё статические файлы.

2. В папке `public` создайте файл `index.html`:

   ```html
   <!DOCTYPE html>
   <html lang="ru">
   <head>
     <meta charset="UTF-8">
     <title>Обратная связь</title>
   </head>
   <body>
     <h1>Форма обратной связи</h1>
     <form action="/submit" method="POST">
       <label>Имя: <input type="text" name="name" required></label><br>
       <label>Email: <input type="email" name="email" required></label><br>
       <label>Сообщение: <textarea name="message" required></textarea></label><br>
       <button type="submit">Отправить</button>
     </form>
   </body>
   </html>
   ```

3. Вернитесь в `server.js` и подключите middleware для отдачи статики **перед** определением маршрутов:

   ```javascript
   // Добавьте эту строку после создания `app`
   app.use(express.static('public'));
   ```

   Теперь любой файл из папки `public` будет доступен по корневому пути. Например, `public/index.html` будет открываться по адресу `http://localhost:3000/`.

4. **Перезапустите сервер** (`Ctrl+C` в терминале, затем снова `node server.js`).

5. **Протестируйте:** Откройте `http://localhost:3000`. Вы должны увидеть вашу HTML-форму.

---

#### **Задача 3: Обработка POST-запроса и сохранение в файл** 

Цель: научиться обрабатывать данные формы и сохранять их на сервере.

1. В `server.js` подключите middleware для парсинга данных формы **перед** определением маршрутов:

   ```javascript
   app.use(express.urlencoded({ extended: true }));
   ```

   Это позволит Express понимать данные, отправленные из HTML-формы, и помещать их в `req.body`.

2. Импортируйте встроенный модуль `fs` (File System) для работы с файлами:

   ```javascript
   const fs = require('fs');
   ```

3. Создайте маршрут для обработки POST-запроса:

   ```javascript
   app.post('/submit', (req, res) => {
     // 1. Получаем данные из формы
     const { name, email, message } = req.body;
   
     // 2. Читаем существующие отзывы из файла (или создаём пустой массив)
     let feedback = [];
     try {
       const data = fs.readFileSync('feedback.json', 'utf8');
       feedback = JSON.parse(data);
     } catch (err) {
       // Если файла нет, оставляем пустой массив
       feedback = [];
     }
   
     // 3. Добавляем новый отзыв
     feedback.push({ name, email, message, date: new Date().toISOString() });
   
     // 4. Записываем обновлённый массив обратно в файл
     fs.writeFileSync('feedback.json', JSON.stringify(feedback, null, 2));
   
     // 5. Отправляем ответ клиенту
     res.json({ success: true, message: 'Ваш отзыв сохранён!' });
   });
   ```

   Мы используем синхронные методы (`readFileSync`, `writeFileSync`) для простоты. В реальных проектах часто используют асинхронные версии.

4. **Перезапустите сервер.**

5. **Протестируйте:** Заполните форму на `http://localhost:3000` и отправьте её. Вы должны увидеть JSON-ответ в браузере. Проверьте корень проекта -- там появился файл `feedback.json` с вашим отзывом.

**Преподаватель:** Поздравляю! Вы только что создали полноценный сервер, который принимает данные от пользователя и сохраняет их на диске. Это огромный шаг от фронтенда к настоящей веб-разработке!

## Часть 3: Мини-проект, ДЗ и Заключение 

### 3\.1. Мини-проект: «Сервер обратной связи» 

**Преподаватель:** Отлично! Теперь, когда вы освоили основы Express, давайте соберём всё в один небольшой, но очень полезный проект -- **сервер обратной связи**.

Этот сервер будет:

-  Отдавать HTML-форму по адресу `/`.

-  Принимать POST-запросы от этой формы и сохранять данные в файл `feedback.json`.

-  Отдавать страницу со списком всех сохранённых отзывов по адресу `/feedback`.

**План выполнения в** `**server.js**`**:**

1. **Добавьте маршрут для страницы отзывов:**

   ```javascript
   app.get('/feedback', (req, res) => {
     try {
       const data = fs.readFileSync('feedback.json', 'utf8');
       const feedback = JSON.parse(data);
       // Создаём простую HTML-страницу со списком
       let html = '<h1>Все отзывы</h1><ul>';
       feedback.forEach(item => {
         html += `<li><strong>${item.name}</strong> (${item.email}): ${item.message} <small>${new Date(item.date).toLocaleString()}</small></li>`;
       });
       html += '</ul><a href="/">← Назад</a>';
       res.send(html);
     } catch (err) {
       res.status(404).send('Отзывов пока нет. <a href="/">Оставить первый?</a>');
     }
   });
   ```

2. **Создайте файл** `**public/feedback.html**` (опционально, но для полноты): Вы можете просто перенаправлять на `/feedback`, как сделано выше, или создать отдельную статическую страницу, которая будет запрашивать данные через `fetch` (но это уже выходит за рамки модуля).

3. **Протестируйте:**

   -  Откройте `http://localhost:3000` -> заполните форму -> получите JSON-ответ.

   -  Откройте `http://localhost:3000/feedback` -> вы увидите список всех отправленных отзывов.

**Преподаватель:** Поздравляю! У вас теперь есть полноценный сервер, который может принимать, хранить и отображать данные. Это уже не просто «Привет, мир!», а настоящий веб-сервис.

---

### 3\.2. Домашнее задание 

**Преподаватель:** Чтобы закрепить материал и подготовиться к следующему модулю, выполните домашнее задание.

**Задание:** Улучшить мини-проект «Сервер обратной связи».

**Требования:**

1. **Добавить middleware для логирования.**\
   Создайте свою middleware-функцию, которая будет выводить в консоль метод, путь и время каждого запроса:

   ```javascript
   app.use((req, res, next) => {
     console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
     next();
   });
   ```

2. **Разделить код на модули.**

   -  Создайте папку `routes` и в ней файл `feedback.js`. Перенесите туда все маршруты, связанные с отзывами. Используйте `express.Router()`.

   -  Создайте папку `controllers` и в ней файл `feedbackController.js`. Перенесите туда всю логику работы с файлом `feedback.json` (чтение, запись).

   -  Подключите роутер в `server.js` с помощью `app.use('/api', feedbackRouter)`.

Это улучшит читаемость и поддерживаемость вашего кода -- важнейший навык для любого бэкенд-разработчика.

**Критерии оценки:**

-  **Оценка 5 (Отлично):** Задание выполнено полностью. Логирование работает, код структурирован по папкам `routes` и `controllers`.

-  **Оценка 4 (Хорошо):** Есть мелкие недочёты (например, логирование есть, но структура не до конца разделена).

-  **Оценка 3 (Удовлетворительно):** Реализована только базовая функциональность без улучшений.

**Срок сдачи:** \[Укажите дату\].

---

### 3\.3. Контрольные вопросы и Заключение 

**Преподаватель:** Давайте подведём итоги и проверим, насколько хорошо вы усвоили материал. Я задам несколько вопросов.

**Контрольные вопросы:**

1. **Чем отличается middleware от обычного обработчика маршрута?**\
   *Ответ:* Middleware выполняется для **всех** запросов (или для запросов, соответствующих определённому пути), а обработчик маршрута -- только для конкретного метода и пути (например, `GET /`). Middleware может вызывать `next()` для передачи управления следующей функции.

2. **Какие объекты передаются в обработчик маршрута и что они содержат?**\
   *Ответ:* Объект `req` (request) содержит информацию о входящем запросе (URL, метод, заголовки, тело). Объект `res` (response) используется для формирования и отправки ответа клиенту (методы `send()`, `json()`, `status()` и др.).

3. **Как заставить Express отдавать статические HTML-файлы?**\
   *Ответ:* С помощью встроенной middleware `express.static('имя_папки')`. Все файлы из указанной папки будут доступны по корневому пути сервера.

**Заключение:**

**Преподаватель:** Сегодня мы совершили прорыв! Мы перешли от фронтенда к бэкенду и научились создавать собственные сервера на JavaScript с помощью **Node.js и Express**. Теперь ваши приложения могут не просто отображать данные, но и **хранить их**, **обрабатывать запросы** и **работать с реальными пользователями**.

Это знание -- фундамент для создания полноценных веб-приложений. В следующем **Модуле 8** мы структурируем наш API по принципам **REST**, научимся выполнять все операции CRUD (Create, Read, Update, Delete) и полностью **свяжем наш React-фронтенд с этим сервером**, чтобы создать единое, работающее приложение.

**Спасибо за внимание!** Удачи в выполнении домашнего задания. Помните: вы уже не просто верстальщик, вы -- **веб-разработчик**!