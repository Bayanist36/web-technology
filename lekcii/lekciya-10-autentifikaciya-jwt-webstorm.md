---
order: 11
title: Лекция 10. Аутентификация (JWT, WebStorm)
---

**Цель:** Научить студентов реализовывать систему аутентификации и авторизации в веб-приложении с использованием JWT (JSON Web Tokens), хэшировать пароли и защищать приватные маршруты на сервере.

---

## Часть 1: Введение и Теоретическая Основа

### 1\.1. Вступление: от открытого к защищённому

**Преподаватель:** Добрый день, коллеги! На предыдущих девяти занятиях мы с вами создали полноценное веб-приложение.\
-- В **Модулях 1–3** мы построили структуру, стиль и поведение.\
-- В **Модуле 4** мы освоили два мощных инструмента: Git/GitHub и htmx.\
-- В **Модулях 5–6** мы погрузились в мир **React**, научившись создавать компонентные интерфейсы и работать с внешними API.\
-- В **Модулях 7–9** мы создали сервер на **Node.js + Express**, построили **REST API**, и подключили его к облачной базе данных **MongoDB**.

Наше приложение умеет хранить данные и синхронизироваться между перезагрузками. Но у него есть **критическая уязвимость**: любой пользователь может видеть и редактировать **все задачи**, включая чужие.

**Сегодня мы решим эту проблему раз и навсегда.**

Наша новая задача -- научиться делать так, чтобы каждый пользователь видел и управлял **только своими данными**.

Для этого нам нужна **система аутентификации и авторизации**:

-  **Аутентификация** -- это процесс проверки личности: «Кто вы?». Мы просим пользователя ввести логин и пароль.

-  **Авторизация** -- это процесс проверки прав доступа: «Что вы можете делать?». После входа система знает, что пользователь может видеть только свои задачи.

И для реализации этой системы мы выберем современный, лёгкий и надёжный стандарт -- **JWT (JSON Web Tokens)**.

---

### 1\.2. Что такое JWT и как он работает?

**Преподаватель:** JWT (произносится как «джот») -- это открытый стандарт (RFC 7519) для безопасной передачи данных между двумя сторонами в виде JSON-объекта.

**Структура JWT** очень проста. Токен состоит из трёх частей, разделённых точками (`.`):

1. **Header (Заголовок):** Содержит метаданные, например, алгоритм подписи (`HS256`) и тип токена (`JWT`).

2. **Payload (Полезная нагрузка):** Содержит сами данные. В нашем случае -- `userId` и, возможно, роль пользователя. **Важно:** эти данные **не шифруются**, они просто кодируются в Base64. Поэтому **никогда не кладите в payload пароли или другие секреты**.

3. **Signature (Подпись):** Это криптографическая подпись, созданная из первых двух частей и **секретного ключа**, который известен только вашему серверу. Именно она гарантирует, что токен не был подделан.

**Как это работает на практике?**

1. Пользователь отправляет свои логин и пароль на сервер (`POST /api/login`).

2. Сервер проверяет данные. Если они верны, он **выдаёт JWT**, в payload которого записан `userId`.

3. Клиент (браузер) получает этот токен и сохраняет его, обычно в `localStorage`.

4. При каждом последующем запросе к защищённым маршрутам (например, `GET /api/todos`) клиент отправляет токен в заголовке:

   ```
   Authorization: Bearer <ваш_токен>
   ```

5. Сервер получает запрос, извлекает токен из заголовка и **проверяет его подпись** с помощью своего секретного ключа.

6. Если подпись валидна, сервер доверяет данным в payload, извлекает `userId` и позволяет обработать запрос. Если подпись невалидна -- возвращается ошибка `403 Forbidden`.

**Главное преимущество JWT:** он позволяет создавать **stateless** (бессостоятельные) сервера. Серверу не нужно хранить сессии в памяти или базе данных. Вся необходимая информация уже есть в самом токене.

---

### 1\.3. Безопасность: хэширование паролей и middleware

**Преподаватель:** Теперь поговорим о двух краеугольных камнях безопасности в нашем приложении.

**Хэширование паролей** -- это **обязательное** требование. **Никогда, ни при каких обстоятельствах не храните пароли пользователей в открытом виде!** Если ваша база данных будет скомпрометирована, все аккаунты пользователей будут украдены.

Вместо этого мы используем библиотеку `bcrypt` для создания **криптографического хэша** пароля.

-  При регистрации: пароль пользователя хэшируется и сохраняется в базе.

-  При входе: введённый пароль хэшируется, и этот хэш сравнивается с хэшем в базе.

-  **Хэш нельзя «расшифровать» обратно в пароль.** Это односторонняя функция.

**Middleware для защиты маршрутов** -- это специальная функция, которая работает как «сторож» перед вашими основными обработчиками маршрутов.

-  Она проверяет наличие и валидность JWT в каждом запросе.

-  Если токен отсутствует или невалиден, middleware немедленно возвращает ошибку `401` или `403` и **не передаёт управление** дальше.

-  Если токен валиден, middleware извлекает из него `userId` и прикрепляет его к объекту `req`, чтобы ваш основной обработчик мог легко получить эту информацию и, например, запросить из базы только те задачи, которые принадлежат этому пользователю.

Это мощный и элегантный способ централизованно защитить все ваши приватные API-маршруты.

## Часть 2: Практическая Часть в WebStorm

### 2\.1. Подготовка окружения

**Преподаватель:** Отлично! Теория усвоена, теперь перейдём к практике. Нам нужно подготовить наше рабочее окружение для реализации аутентификации.

1. **Откройте проект в WebStorm:**\
   Откройте ваш проект из **Модуля 9** (`feedback-server` или аналогичный), который уже содержит REST API для задач и подключение к MongoDB.

2. **Установите необходимые зависимости:**\
   В терминале WebStorm выполните команду:

   ```bash
   npm install jsonwebtoken bcrypt dotenv
   ```

   -  `jsonwebtoken` -- для создания и проверки JWT.

   -  `bcrypt` -- для безопасного хэширования паролей.

   -  `dotenv` -- для загрузки переменных окружения (мы уже использовали его, но убедимся, что он есть).

3. **Обновите файл** `**.env**`**:**\
   Откройте файл `.env` в корне проекта и добавьте в него секретный ключ для JWT:

   ```env
   MONGO_URI=ваша_строка_подключения_к_MongoDB
   JWT_SECRET=super_secret_key_for_jwt_12345
   ```

   **Важно:** Этот ключ должен быть длинным, случайным и **никогда не должен попадать в Git**. Убедитесь, что `.env` есть в вашем `.gitignore`.

4. **Создайте структуру папок:**\
   В корне проекта создайте папку `middleware`. В ней мы разместим нашу функцию для проверки токена.

Теперь у нас всё готово для написания кода аутентификации.

---

### 2\.2. Практические задачи

#### **Задача 1: Регистрация пользователя**

Цель: создать модель пользователя и маршрут для регистрации.

1. **Создайте модель** `**User**` **(**`**models/User.js**`**):**

   ```javascript
   const mongoose = require('mongoose');
   const bcrypt = require('bcrypt');
   
   const userSchema = new mongoose.Schema({
     email: { type: String, required: true, unique: true },
     password: { type: String, required: true }
   });
   
   // Middleware для хэширования пароля перед сохранением
   userSchema.pre('save', async function (next) {
     if (!this.isModified('password')) return next();
     this.password = await bcrypt.hash(this.password, 10);
     next();
   });
   
   module.exports = mongoose.model('User', userSchema);
   ```

   Здесь мы используем хук `pre('save')`, чтобы автоматически хэшировать пароль каждый раз, когда создаётся или обновляется пользователь.

2. **Создайте маршрут регистрации (**`**routes/auth.js**`**):**

   ```javascript
   const express = require('express');
   const User = require('../models/User');
   const router = express.Router();
   
   router.post('/register', async (req, res) => {
     try {
       const { email, password } = req.body;
       if (!email || !password) {
         return res.status(400).json({ error: 'Email и пароль обязательны' });
       }
   
       // Проверяем, не существует ли уже такой пользователь
       const existingUser = await User.findOne({ email });
       if (existingUser) {
         return res.status(409).json({ error: 'Пользователь с таким email уже существует' });
       }
   
       // Создаём нового пользователя
       const user = new User({ email, password });
       await user.save();
   
       // Возвращаем ответ без пароля
       res.status(201).json({ id: user._id, email: user.email });
     } catch (err) {
       console.error(err);
       res.status(500).json({ error: 'Ошибка при регистрации' });
     }
   });
   
   module.exports = router;
   ```

3. **Подключите роутер в** `**server.js**`**:**

   ```javascript
   const authRouter = require('./routes/auth');
   app.use('/api/auth', authRouter);
   ```

---

#### **Задача 2: Логин и выдача JWT**

Цель: реализовать вход и выдачу токена.

1. **Добавьте маршрут логина в** `**routes/auth.js**`**:**

   ```javascript
   const jwt = require('jsonwebtoken');
   
   // ... предыдущий код ...
   
   router.post('/login', async (req, res) => {
     try {
       const { email, password } = req.body;
       if (!email || !password) {
         return res.status(400).json({ error: 'Email и пароль обязательны' });
       }
   
       // Находим пользователя
       const user = await User.findOne({ email });
       if (!user) {
         return res.status(401).json({ error: 'Неверные данные для входа' });
       }
   
       // Сравниваем пароли
       const isPasswordValid = await bcrypt.compare(password, user.password);
       if (!isPasswordValid) {
         return res.status(401).json({ error: 'Неверные данные для входа' });
       }
   
       // Создаём и выдаём JWT
       const token = jwt.sign(
         { userId: user._id },
         process.env.JWT_SECRET,
         { expiresIn: '1h' }
       );
   
       res.json({ token, userId: user._id });
     } catch (err) {
       console.error(err);
       res.status(500).json({ error: 'Ошибка при входе' });
     }
   });
   ```

2. **Протестируйте регистрацию и логин:**\
   Используйте WebStorm HTTP Client или Postman, чтобы:

   -  Зарегистрировать нового пользователя (`POST /api/auth/register`).

   -  Выполнить вход (`POST /api/auth/login`) и получить JWT.

---

#### **Задача 3: Защита маршрутов задач**

Цель: сделать так, чтобы только авторизованные пользователи могли управлять своими задачами.

1. **Создайте middleware для проверки токена (**`**middleware/auth.js**`**):**

   ```javascript
   const jwt = require('jsonwebtoken');
   
   function authMiddleware(req, res, next) {
     // Извлекаем токен из заголовка Authorization
     const authHeader = req.headers.authorization;
     if (!authHeader || !authHeader.startsWith('Bearer ')) {
       return res.status(401).json({ error: 'Токен не предоставлен' });
     }
   
     const token = authHeader.split(' ')[1]; // Получаем сам токен
   
     try {
       // Проверяем и декодируем токен
       const decoded = jwt.verify(token, process.env.JWT_SECRET);
       req.user = decoded; // Прикрепляем данные пользователя к запросу
       next(); // Передаём управление следующему middleware или обработчику
     } catch (err) {
       return res.status(403).json({ error: 'Неверный или просроченный токен' });
     }
   }
   
   module.exports = authMiddleware;
   ```

2. **Обновите схему** `**Todo**` **(**`**models/Todo.js**`**):**\
   Добавьте поле `owner` для привязки задачи к пользователю:

   ```javascript
   const todoSchema = new mongoose.Schema({
     title: { type: String, required: true },
     completed: { type: Boolean, default: false },
     owner: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true }
   });
   ```

3. **Защитите маршруты и обновите логику (**`**routes/todos.js**`**):**

   -  Импортируйте middleware и модель User:

      ```javascript
      const authMiddleware = require('../middleware/auth');
      const User = require('../models/User');
      ```

   -  Примените middleware ко всем маршрутам:

      ```javascript
      router.use(authMiddleware);
      ```

   -  Обновите обработчик `POST /api/todos`, чтобы он сохранял `owner`:

      ```javascript
      router.post('/', async (req, res) => {
        try {
          const { title } = req.body;
          const newTodo = await Todo.create({
            title,
            owner: req.user.userId // Используем ID из токена
          });
          res.status(201).json(newTodo);
        } catch (err) {
          // ... обработка ошибок ...
        }
      });
      ```

   -  Обновите другие маршруты (`GET`, `PUT`, `DELETE`), чтобы они фильтровали задачи по `owner: req.user.userId`.

4. **Протестируйте защищённые маршруты:**\
   Теперь, чтобы получить список задач, вы должны отправить запрос с заголовком:

   ```
   Authorization: Bearer ваш_токен_здесь
   ```

   Без токена сервер вернёт ошибку `401`.

**Преподаватель:** Поздравляю! Ваши данные теперь защищены. Каждый пользователь видит и управляет только своими задачами.

Продолжаю писать подробную лекцию по **Модулю 10: Аутентификация (JWT, WebStorm-версия)**.

---

## Часть 3: Мини-проект, ДЗ и Заключение 

### 3\.1. Мини-проект: «Личный кабинет с авторизацией» 

**Преподаватель:** Отлично! Теперь, когда у вас есть работающая система регистрации, входа и защищённые маршруты, давайте соберём всё в единое приложение -- **Личный кабинет с авторизацией**.

Этот проект завершает цикл безопасности в нашем веб-приложении. Теперь каждый пользователь будет работать только со своими данными.

**Требования к проекту:**

1. **Фронтенд (React):**

   -  Страницы `/register` и `/login` с формами.

   -  После успешного входа токен сохраняется в `localStorage`.

   -  При каждом запросе к API (`/api/todos`) в заголовке `Authorization` передаётся токен.

   -  Если токен отсутствует (пользователь не залогинен), кнопки «Добавить задачу» и другие приватные элементы **скрыты**.

2. **Бэкенд (Express):**

   -  Все маршруты в `/api/todos` защищены middleware `authMiddleware`.

   -  При создании, обновлении или удалении задачи используется `req.user.userId` для привязки к конкретному пользователю.

   -  При получении списка задач (`GET /api/todos`) сервер возвращает только те задачи, у которых `owner` совпадает с `req.user.userId`.

**План выполнения:**

1. **Доработайте React-компоненты:**

   -  Создайте компоненты `Register` и `Login`.

   -  В компоненте `App` добавьте логику для проверки наличия токена в `localStorage` и условного рендеринга приватных элементов.

   -  Оберните все `fetch`\-запросы к `/api/todos` в функцию, которая автоматически добавляет заголовок `Authorization`.

2. **Убедитесь в работоспособности бэкенда:**

   -  Протестируйте API через Postman, отправляя запросы с и без токена.

   -  Убедитесь, что задачи одного пользователя не видны другому.

3. **Протестируйте полный цикл:**

   -  Зарегистрируйте двух пользователей.

   -  Залогиньтесь под первым и добавьте несколько задач.

   -  Выйдите и залогиньтесь под вторым. Список должен быть пустым.

   -  Добавьте свои задачи.

   -  Убедитесь, что данные не пересекаются.

**Преподаватель:** Поздравляю! Ваше приложение теперь безопасно и персонализировано. Это уже не просто учебный проект, а полноценное веб-приложение, готовое к деплою.

---

### 3\.2. Домашнее задание 

**Преподаватель:** Чтобы закрепить материал и подготовиться к финальному шагу -- деплою, выполните домашнее задание.

**Задание:** Улучшить систему аутентификации.

**Требования:**

1. **Добавить refresh-токен:**

   -  При входе (`/api/login`) сервер должен возвращать **два токена**: короткоживущий `access_token` (15 минут) и долгоживущий `refresh_token` (7 дней).

   -  Реализуйте маршрут `/api/refresh`, который принимает `refresh_token`, проверяет его и выдаёт новый `access_token`.

   -  На фронтенде реализуйте логику автоматического обновления `access_token` при его истечении.

2. **Скрыть приватные элементы UI:**

   -  В React-приложении создайте глобальное состояние (например, через `useState` в `App`), которое отслеживает, залогинен ли пользователь.

   -  Если пользователь не залогинен, скрывайте кнопку «Добавить задачу» и другие приватные элементы интерфейса.

**Критерии оценки:**

-  **Оценка 5 (Отлично):** Задание выполнено полностью. Refresh-токен работает, UI корректно скрывается и отображается.

-  **Оценка 4 (Хорошо):** Есть мелкие недочёты (например, UI скрывается, но refresh-токен не реализован).

-  **Оценка 3 (Удовлетворительно):** Реализована только базовая аутентификация.

**Срок сдачи:** \[Укажите дату\].

---

### 3\.3. Контрольные вопросы и Заключение 

**Преподаватель:** Давайте подведём итоги и проверим, насколько хорошо вы усвоили материал. Я задам несколько вопросов.

**Контрольные вопросы:**

1. **Где безопаснее всего хранить JWT на клиенте?**\
   *Ответ:* Для простых веб-приложений допустимо хранение в `localStorage`. Однако для повышенной безопасности (защиты от XSS-атак) рекомендуется хранить токен в **HTTP-only cookie**. В нашем учебном проекте мы используем `localStorage` для простоты.

2. **Как выставить срок жизни токена и что делать при его истечении?**\
   *Ответ:* Срок жизни задаётся в опции `expiresIn` при создании токена (`{ expiresIn: '1h' }`). При истечении срока метод `jwt.verify()` выбросит ошибку. На клиенте нужно перехватывать ошибку `401` от сервера и перенаправлять пользователя на страницу входа или использовать `refresh_token` для получения нового `access_token`.

3. **Почему важно хэшировать пароли, а не шифровать их?**\
   *Ответ:* **Хэширование** -- это односторонняя функция. Из хэша невозможно восстановить исходный пароль. **Шифрование** -- двухстороннее: при наличии ключа можно расшифровать данные. Если злоумышленник получит доступ к базе с зашифрованными паролями и ключом, он получит все пароли. С хэшами этого сделать нельзя.

**Заключение:**

**Преподаватель:** Сегодня мы добавили критически важный слой безопасности в наше приложение. Теперь данные пользователей защищены, и каждый работает только со своим контентом. Мы освоили современный стандарт аутентификации -- JWT, научились хэшировать пароли и защищать приватные маршруты.

Это был последний технический модуль нашего интенсива. В следующем, **Модуле 11**, мы сделаем финальный шаг: мы задеплоим наше приложение в облако на платформы **Vercel** (фронтенд) и **Render** (бэкенд). После этого ваш To-Do List станет доступен всему миру!

**Спасибо за внимание!** Удачи в выполнении домашнего задания. Вы уже создали приложение, которое использует профессиональный стек технологий и готово к реальному использованию!