---
order: 9
title: "Лекция 8. REST API "
---

**Цель:** Научить студентов проектировать и реализовывать серверное API по принципам REST, выполнять CRUD-операции (Create, Read, Update, Delete) и интегрировать его с React-фронтендом для создания полноценного веб-приложения.

---

## Часть 1: Введение и Теоретическая Основа

### 1\.1. Вступление: от сервера к API

**Преподаватель:** Добрый день, коллеги! На предыдущих семи занятиях мы с вами прошли путь от простой HTML-страницы до полноценного веб-приложения с фронтендом и бэкендом.\
-- В **Модулях 1–3** мы создали структуру, стиль и поведение.\
-- В **Модуле 4** мы освоили два мощных инструмента: Git/GitHub и htmx.\
-- В **Модулях 5–6** мы погрузились в мир **React**, научившись создавать компонентные интерфейсы и работать с внешними API.\
-- В **Модуле 7** мы сделали огромный шаг вперёд, создав собственный сервер на **Node.js + Express**, который мог принимать форму и сохранять данные в файл.

Но наш сервер из Модуля 7 был «глупым». Он не имел чёткой структуры, не мог полноценно общаться с современным React-фронтендом и не следовал никаким стандартам.

**Сегодня мы решим эту проблему.**

Наша новая задача -- научиться создавать **REST API**. Это архитектурный стиль, который задаёт чёткие правила, как клиент (ваш React-фронтенд) и сервер должны взаимодействовать через HTTP.

**Почему это важно?**

-  **Предсказуемость:** Любой разработчик, знакомый с REST, сразу поймёт, как работает ваше API.

-  **Отделение фронтенда от бэкенда:** Команды могут работать независимо. Фронтендеры могут использовать ваше API даже до того, как бэкенд будет полностью готов, просто подключившись к «заглушке».

-  **Масштабируемость:** Чёткая структура позволяет легко расширять функциональность.

После этого занятия ваш React-фронтенд и ваш Express-сервер наконец-то заговорят на одном языке и станут единым, работающим приложением.

---

### 1\.2. Принципы REST и CRUD

**Преподаватель:** Давайте разберёмся, что же такое REST и как его применять на практике.

**REST (Representational State Transfer)** -- это не технология, а **набор принципов** для построения веб-сервисов. Его суть сводится к нескольким ключевым идеям:

1. **Всё -- это ресурс (Resource).**\
   Любая сущность в вашем приложении -- задача, пользователь, статья -- является ресурсом. Каждый ресурс имеет уникальный адрес (URL). Например:

   -  `/api/todos` -- коллекция всех задач.

   -  `/api/todos/123` -- конкретная задача с ID `123`.

2. **Действия -- это HTTP-методы.**\
   Вместо того чтобы придумывать свои глаголы (`/api/todos/create`, `/api/todos/delete`), мы используем стандартные HTTP-методы как глаголы:

   -  `GET` -- **получить** данные (прочитать ресурс).

   -  `POST` -- **создать** новый ресурс.

   -  `PUT` / `PATCH` -- **обновить** существующий ресурс.

   -  `DELETE` -- **удалить** ресурс.

3. **Данные передаются в формате JSON.**\
   И тело запроса (`req.body`), и тело ответа (`res.json()`) должны быть в формате JSON. Это стандарт де-факто для JavaScript-приложений.

Эти четыре операции -- **CRUD** (Create, Read, Update, Delete) -- лежат в основе почти любого веб-приложения.

**Пример маршрутов для сущности** `**todos**`**:**

-  `GET /api/todos` -> Получить список всех задач.

-  `POST /api/todos` -> Создать новую задачу.

-  `PUT /api/todos/:id` -> Обновить задачу с указанным ID.

-  `DELETE /api/todos/:id` -> Удалить задачу с указанным ID.

---

### 1\.3. Статус-коды и CORS

**Преподаватель:** Теперь поговорим о двух важнейших аспектах профессионального API: **статус-кодах** и **CORS**.

**HTTP-статус-коды** -- это способ сервера сообщить клиенту, успешно ли был обработан запрос. Они делятся на несколько групп:

-  `**2xx**` **-- Успех:**

   -  `200 OK` -- Запрос успешен, и в ответе есть данные (обычно для `GET`).

   -  `201 Created` -- Ресурс успешно создан (для `POST`). В ответе часто возвращают созданный объект.

   -  `204 No Content` -- Запрос успешен, но в ответе **нет тела** (обычно для `DELETE` или `PUT`, если не нужно возвращать данные).

-  `**4xx**` **-- Ошибка клиента:**

   -  `400 Bad Request` -- Сервер не понял запрос (например, отправлены некорректные данные).

   -  `404 Not Found` -- Запрашиваемый ресурс не существует (например, задача с ID `999` не найдена).

-  `**5xx**` **-- Ошибка сервера:**

   -  `500 Internal Server Error` -- Что-то сломалось на сервере. Это наша вина, а не клиента.

Правильное использование статус-кодов делает ваше API понятным и надёжным.

**CORS (Cross-Origin Resource Sharing)** -- это механизм безопасности браузера. По умолчанию браузер **запрещает** веб-странице делать запросы на другой домен или порт. Например, ваш React-фронтенд на `http://localhost:3000` не может отправить запрос на ваш сервер на `http://localhost:5000`.

**Решение:** На сервере нужно установить специальные HTTP-заголовки, которые разрешают такие запросы. В Express это делается с помощью middleware `cors()`.

```javascript
const cors = require('cors');
app.use(cors()); // Разрешает запросы со всех доменов (только для разработки!)
```

Без этого ваш фронтенд просто не сможет связаться с вашим сервером.

## Часть 2: Практическая Часть в WebStorm

### 2\.1. Подготовка проекта

**Преподаватель:** Отлично! Теория усвоена, теперь перейдём к практике. Нам понадобятся два проекта:

1. **Бэкенд-сервер** из **Модуля 7** (`feedback-server`).

2. **Фронтенд-приложение** из **Модуля 5** (`my-todo-app`).

3. Откройте папку `feedback-server` в **WebStorm**.

4. Убедитесь, что в терминале вы находитесь в корне этого проекта.

5. Установите необходимую зависимость для работы с CORS:

   ```bash
   npm install cors
   ```

6. Создайте папку `routes` и в ней файл `todos.js`. Это будет наш файл для маршрутов задач.

Теперь у нас всё готово для создания профессионального REST API.

---

### 2\.2. Практические задачи

#### **Задача 1: Создание REST API для задач**

Цель: реализовать полный набор CRUD-операций для сущности «задача».

1. **Настройка сервера (**`**server.js**`**):**

   -  Импортируйте и подключите `cors`:

      ```javascript
      const cors = require('cors');
      app.use(cors()); // Разрешаем CORS для всех доменов (только для разработки!)
      ```

   -  Подключите роутер для задач (мы создадим его на следующем шаге):

      ```javascript
      const todosRouter = require('./routes/todos');
      app.use('/api/todos', todosRouter);
      ```

   -  Измените порт на `5000`, чтобы не конфликтовать с React (`localhost:3000`):

      ```javascript
      const PORT = 5000;
      ```

2. **Создание маршрутов (**`**routes/todos.js**`**):**

   -  Начните с импорта Express и создания роутера:

      ```javascript
      const express = require('express');
      const router = express.Router();
      
      // Временное хранилище в памяти (в Модуле 9 мы заменим это на MongoDB)
      let todos = [
        { id: 1, text: 'Изучить REST API', isCompleted: false },
        { id: 2, text: 'Подключить фронтенд', isCompleted: true }
      ];
      let nextId = 3;
      ```

   -  **Реализуйте маршрут** `**GET /api/todos**`**:**

      ```javascript
      router.get('/', (req, res) => {
        res.status(200).json(todos);
      });
      ```

   -  **Реализуйте маршрут** `**POST /api/todos**`**:**

      ```javascript
      router.post('/', (req, res) => {
        const { text } = req.body;
        if (!text) {
          return res.status(400).json({ error: 'Текст задачи обязателен' });
        }
        const newTodo = { id: nextId++, text, isCompleted: false };
        todos.push(newTodo);
        res.status(201).json(newTodo); // 201 Created
      });
      ```

   -  **Реализуйте маршрут** `**PUT /api/todos/:id**`**:**

      ```javascript
      router.put('/:id', (req, res) => {
        const id = parseInt(req.params.id);
        const todoIndex = todos.findIndex(t => t.id === id);
        if (todoIndex === -1) {
          return res.status(404).json({ error: 'Задача не найдена' });
        }
        const { text, isCompleted } = req.body;
        todos[todoIndex] = { ...todos[todoIndex], text, isCompleted };
        res.status(200).json(todos[todoIndex]);
      });
      ```

   -  **Реализуйте маршрут** `**DELETE /api/todos/:id**`**:**

      ```javascript
      router.delete('/:id', (req, res) => {
        const id = parseInt(req.params.id);
        const todoIndex = todos.findIndex(t => t.id === id);
        if (todoIndex === -1) {
          return res.status(404).json({ error: 'Задача не найдена' });
        }
        todos.splice(todoIndex, 1);
        res.status(204).send(); // 204 No Content
      });
      ```

   -  Не забудьте экспортировать роутер в конце файла:

      ```javascript
      module.exports = router;
      ```

3. **Тестирование API:**

   -  Запустите сервер: `node server.js`.

   -  Откройте **встроенный HTTP-клиент WebStorm** (или Postman).

   -  Отправьте запрос `GET http://localhost:5000/api/todos` -- вы должны получить массив задач в формате JSON.

   -  Отправьте запрос `POST http://localhost:5000/api/todos` с телом:

      ```json
      { "text": "Новая задача из API" }
      ```

      Вы должны получить статус `201` и созданную задачу в ответе.

   -  Попробуйте `DELETE` и `PUT` для полноты картины.

**Преподаватель:** Поздравляю! У вас теперь есть полноценный, стандартизированный REST API.

---

#### **Задача 2: Подключение React-фронтенда**

Цель: заставить ваш React-фронтенд общаться с этим новым API.

1. **Откройте второй проект в WebStorm:** `my-todo-app` (в новом окне IDE).

2. **Модифицируйте компонент** `**App.js**`**:**

   -  Замените локальное состояние на запросы к API.

   -  Импортируйте `useEffect` и обновите состояние:

      ```jsx
      import { useState, useEffect } from 'react';
      
      function App() {
        const [todos, setTodos] = useState([]);
        const [inputValue, setInputValue] = useState('');
      
        // Загрузка задач при старте
        useEffect(() => {
          fetch('http://localhost:5000/api/todos')
            .then(res => res.json())
            .then(data => setTodos(data));
        }, []);
      
        // Функция добавления задачи
        const addTodo = async (e) => {
          e.preventDefault();
          const response = await fetch('http://localhost:5000/api/todos', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: inputValue })
          });
          const newTodo = await response.json();
          setTodos([...todos, newTodo]);
          setInputValue('');
        };
      
        // Остальной код для рендера формы и списка остаётся почти без изменений
        // ...
      }
      ```

3. **Запустите оба проекта:**

   -  В первом терминале (бэкенд): `node server.js`.

   -  Во втором терминале (фронтенд): `npm start`.

4. **Протестируйте:** Откройте React-приложение в браузере (`http://localhost:3000`). Теперь все задачи загружаются с сервера, и новые задачи сохраняются на сервере! При перезагрузке страницы список не исчезает.

**Преподаватель:** Это и есть магия полноценного веб-приложения! Фронтенд и бэкенд теперь работают в тесной связке через стандартизированный REST API.

## Часть 3: Мини-проект, ДЗ и Заключение 

### 3\.1. Мини-проект: «To-Do List на React с серверным API» 

**Преподаватель:** Отлично! Теперь, когда вы успешно подключили фронтенд к бэкенду, давайте соберём всё в единое, законченное приложение -- **To-Do List с серверным API**.

Этот проект объединяет всё, что вы изучили за последние три модуля:

-  **React** из Модуля 5 для интерфейса.

-  **useEffect и формы** из Модуля 6 для взаимодействия с API.

-  **Express и REST** из Модулей 7–8 для серверной логики.

**Требования к проекту:**

1. **Бэкенд (Express):** Полноценный REST API с поддержкой всех CRUD-операций для задач. Каждая задача должна иметь поля: `id`, `text`, `isCompleted`.

2. **Фронтенд (React):** Интерфейс, который полностью работает с этим API. При загрузке страницы задачи подгружаются с сервера. Все действия (добавление, удаление, отметка как выполненной) отправляют запросы на сервер.

3. **Функционал:**

   -  Добавление новой задачи через форму.

   -  Удаление задачи по клику на крестик.

   -  Отметка задачи как выполненной через чекбокс.

   -  Фильтрация задач на фронтенде: показывать «Все» или только «Активные».

**План выполнения:**

1. **Доработайте API:** Убедитесь, что ваш маршрут `PUT /api/todos/:id` может обновлять поле `isCompleted`.

2. **Доработайте React-компонент:**

   -  Добавьте состояние `filter` (`'all'` или `'active'`).

   -  Создайте функцию `toggleTodo` для отправки `PUT`\-запроса при клике на чекбокс.

   -  Отфильтруйте список задач перед рендером:

      ```jsx
      const filteredTodos = filter === 'active' 
        ? todos.filter(todo => !todo.isCompleted) 
        : todos;
      ```

3. **Протестируйте:** Убедитесь, что все операции синхронизируются с сервером и сохраняются между перезагрузками.

**Преподаватель:** Это ваш первый полноценный веб-проект с разделением на клиент и сервер. Вы не просто пишете код -- вы создаёте архитектуру!

---

### 3\.2. Домашнее задание 

**Преподаватель:** Чтобы закрепить материал и подготовиться к следующему модулю, выполните домашнее задание.

**Задание:** Улучшить мини-проект «To-Do List».

**Требования:**

1. **Добавить фильтрацию на сервере.**\
   Вместо фильтрации на фронтенде, реализуйте её на бэкенде через query-параметры. Например:

   -  `GET /api/v1/todos?completed=false` -- вернёт только активные задачи.

   -  Обновите фронтенд, чтобы он отправлял правильный запрос в зависимости от выбранного фильтра.

2. **Версионировать API.**\
   Измените базовый путь всех маршрутов с `/api/todos` на `/api/v1/todos`. Это стандартная практика, которая позволяет в будущем выпускать новые версии API без поломки существующих клиентов.

**Критерии оценки:**

-  **Оценка 5 (Отлично):** Задание выполнено полностью. Фильтрация работает на сервере, API версионировано.

-  **Оценка 4 (Хорошо):** Есть мелкие недочёты (например, фильтрация есть, но версионирование не реализовано).

-  **Оценка 3 (Удовлетворительно):** Реализована только базовая CRUD-функциональность.

**Срок сдачи:** \[Укажите дату\].

---

### 3\.3. Контрольные вопросы и Заключение 

**Преподаватель:** Давайте подведём итоги и проверим, насколько хорошо вы усвоили материал. Я задам несколько вопросов.

**Контрольные вопросы:**

1. **Когда следует возвращать статус** `**201 Created**`**, а когда** `**204 No Content**`**?**\
   *Ответ:* `201 Created` возвращается после успешного создания нового ресурса, обычно с телом ответа, содержащим созданный объект. `204 No Content` возвращается после успешного выполнения операции, когда возвращать тело ответа не нужно (например, после удаления ресурса).

2. **Что должно передаваться в теле запроса (**`**body**`**), а что в параметрах URL (**`**query**` **или** `**params**`**)?**\
   *Ответ:* В **параметрах URL (**`**params**`**)** передаются идентификаторы ресурсов (например, `/todos/:id`). В **query-параметрах** -- данные для фильтрации, сортировки или пагинации (например, `?page=2&limit=10`). В **теле запроса (**`**body**`**)** -- данные для создания или обновления ресурса (например, JSON с текстом новой задачи).

3. **Как решить проблему CORS при разработке с локальным сервером и фронтендом?**\
   *Ответ:* На сервере нужно подключить middleware `cors()`. В Express это делается так: `const cors = require('cors'); app.use(cors());`. Это добавляет необходимые заголовки в ответ, разрешающие браузеру делать кросс-доменные запросы.

**Заключение:**

**Преподаватель:** Сегодня мы совершили важнейший шаг в становлении полноценного веб-разработчика. Мы научились проектировать и реализовывать профессиональное, стандартизированное **REST API**, которое служит мостом между фронтендом и бэкендом.

Теперь у вас есть все инструменты для создания сложных, масштабируемых и надёжных веб-приложений. Вы больше не просто пишете код -- вы проектируете архитектуру.

В следующем **Модуле 9** мы сделаем ещё один гигантский шаг вперёд: мы перейдём от хранения данных в памяти к настоящей базе данных -- **MongoDB**. Наши задачи, отзывы и пользователи наконец-то получат постоянное, надёжное хранилище.

**Спасибо за внимание!** Удачи в выполнении домашнего задания. Помните: вы уже создали своё первое полноценное веб-приложение!