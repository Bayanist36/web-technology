---
order: 7
title: "Лекция 6. React: формы и эффекты (WebStorm-версия)"
---

**Цель:** Научить студентов создавать управляемые формы в React, выполнять запросы к внешним API и использовать хук `useEffect` для работы с побочными эффектами, такими как загрузка данных, подписки и обновление DOM вне основного рендера.

---

## Часть 1: Введение и Теоретическая Основа 

### 1\.1. Вступление: от статики к динамике 

**Преподаватель:** Добрый день, коллеги! На предыдущем занятии мы с вами сделали огромный шаг -- познакомились с **React** и научились создавать компонентные интерфейсы. Мы разобрались с **JSX**, **пропсами**, **состоянием** (`useState`) и даже собрали свой первый **To-Do List**.

Но давайте честно: наш To-Do List пока что живёт **только в браузере**. Все данные исчезают при перезагрузке страницы, и мы не можем взаимодействовать с внешним миром. Это как красивый, но закрытый в себе мир.

**Сегодня мы откроем дверь в реальный мир.**

Наша новая задача -- научить наше React-приложение:

-  **Общаться с пользователем** через надёжные и валидируемые формы.

-  **Общаться с серверами** -- получать и отправлять данные через публичные API.

Для этого нам понадобятся два мощных инструмента:

1. **Управляемые формы** -- чтобы полностью контролировать пользовательский ввод.

2. **Хук** `**useEffect**` -- чтобы выполнять так называемые **побочные эффекты**, такие как сетевые запросы, работа с таймерами или подписки на события.

Эти два понятия -- фундамент для создания по-настоящему динамичных и полезных приложений. После этого занятия ваш To-Do List сможет не просто хранить задачи в памяти, а загружать их с сервера и отправлять новые задачи на сохранение.

---

### 1\.2. Управляемые формы в React 

**Преподаватель:** Давайте начнём с форм. В обычном HTML форма «владеет» своими данными. Когда вы вводите текст в поле, это значение хранится внутри DOM-элемента `<input>`. Это называется **неуправляемой формой**.

Проблема такого подхода в том, что для получения значения вам нужно «залезать» в DOM с помощью `document.getElementById()`. Это нарушает основной принцип React: **всё состояние должно быть в одном месте** -- в вашем компоненте.

**Решение -- управляемые компоненты.**

В управляемой форме **источником «правды» становится состояние React**, а не DOM. Каждое поле формы связано со своим значением в состоянии через атрибут `value`. Любое изменение в поле обрабатывается через обработчик `onChange`, который обновляет состояние.

**Как это выглядит на практике?**

```jsx
import { useState } from 'react';

function EmailForm() {
  // Состояние для хранения значения email
  const [email, setEmail] = useState('');

  return (
    <form>
      <label htmlFor="email">Email:</label>
      <input
        id="email"
        type="email"
        // Значение берётся из состояния
        value={email}
        // При любом изменении обновляем состояние
        onChange={(e) => setEmail(e.target.value)}
      />
    </form>
  );
}
```

**Преимущества управляемых форм:**

-  **Полный контроль:** Вы всегда знаете, какое значение находится в поле.

-  **Мгновенная валидация:** Вы можете проверять данные в реальном времени и сразу показывать ошибки.

-  **Предсказуемость:** Поведение формы полностью определяется состоянием, что упрощает отладку.

**Валидация** -- это неотъемлемая часть любой формы. Вы можете хранить ошибки в отдельном состоянии и отображать их под полями:

```jsx
const [errors, setErrors] = useState({});

const validate = () => {
  const newErrors = {};
  if (!email) newErrors.email = 'Email обязателен';
  else if (!email.includes('@')) newErrors.email = 'Некорректный email';
  setErrors(newErrors);
  return Object.keys(newErrors).length === 0; // true, если ошибок нет
};
```

---

### 1\.3. Хук `useEffect` и побочные эффекты 

**Преподаватель:** Теперь поговорим о втором китовом камне сегодняшнего занятия -- хуке `useEffect`.

**Что такое побочный эффект?**\
Это любая операция, которая **выходит за рамки чистого рендеринга компонента**. Например:

-  Запрос данных с сервера.

-  Установка таймера (`setTimeout`).

-  Работа с DOM напрямую (например, изменение заголовка страницы).

-  Подписка на внешние события (например, геолокация).

Во время рендера компонента React ожидает, что функция компонента просто вернёт JSX. Любые побочные эффекты внутри неё могут привести к ошибкам и нестабильности.

**Хук** `**useEffect**` **решает эту проблему.** Он говорит React: «Выполни этот код **после** того, как компонент отрендерился».

**Базовый синтаксис:**

```jsx
useEffect(() => {
  // Ваш побочный эффект здесь
}, [dependencies]); // Массив зависимостей
```

**Как работает массив зависимостей?**

-  `**\[\]**` **(пустой массив):** Эффект выполняется **один раз** при монтировании компонента. Это аналог `componentDidMount` в классовых компонентах.

-  `**\[data\]**` **(массив с переменными):** Эффект выполняется при монтировании и **каждый раз, когда** `**data**` **меняется**. Это аналог `componentDidUpdate`.

-  **Отсутствие массива:** Эффект выполняется **после каждого рендера**. Используйте с осторожностью!

**Пример: Загрузка данных с API**

```jsx
import { useState, useEffect } from 'react';

function PostList() {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);

  // Этот эффект сработает один раз при загрузке компонента
  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts')
      .then(response => response.json())
      .then(data => {
        setPosts(data);
        setLoading(false);
      });
  }, []); // Пустой массив зависимостей

  if (loading) return <p>Загрузка...</p>;

  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

**Очистка эффектов:**\
Иногда эффекты нужно «отменять» при размонтировании компонента (например, отмена сетевого запроса или удаление слушателя). Для этого функция внутри `useEffect` может **возвращать другую функцию**, которая будет вызвана при размонтировании.

```jsx
useEffect(() => {
  const timer = setTimeout(() => {
    console.log('Таймер сработал!');
  }, 1000);

  // Функция очистки
  return () => clearTimeout(timer);
}, []);
```

Это мощный механизм, который помогает избежать утечек памяти и ошибок.

## Часть 2: Практическая Часть в WebStorm 

### 2\.1. Подготовка проекта 

**Преподаватель:** Отлично! Теория усвоена, теперь перейдём к практике. Мы будем работать в том же проекте, который вы создали в Модуле 5 -- вашем **To-Do List на React**.

1. Откройте папку проекта (`my-todo-app` или аналогичную) в **WebStorm**.

2. Убедитесь, что проект запускается: в терминале выполните `npm start`. Страница должна открыться по адресу `http://localhost:3000`.

3. (Опционально) Для удобства работы с API установим популярную библиотеку `axios`. В терминале выполните:

   ```bash
   npm install axios
   ```

   `axios` предоставляет более удобный и читаемый API для HTTP-запросов по сравнению с встроенным `fetch`.

Теперь у нас всё готово для выполнения практических задач.

---

### 2\.2. Практические задачи 

#### **Задача 1: Форма регистрации с валидацией** 

Цель: научиться создавать надёжные управляемые формы и проводить валидацию данных.

1. В папке `src` создайте новый файл `RegistrationForm.js`.

2. Начните с импорта необходимых хуков и экспорта компонента:

   ```jsx
   import { useState } from 'react';
   
   export default function RegistrationForm() {
     // Ваш код будет здесь
   }
   ```

3. Объявите состояние для полей формы и для ошибок:

   ```jsx
   const [formData, setFormData] = useState({
     name: '',
     email: '',
     password: ''
   });
   const [errors, setErrors] = useState({});
   ```

   Здесь мы используем один объект `formData` для хранения всех значений, что упрощает управление.

4. Создайте обработчик для изменения полей. Он будет универсальным для всех полей:

   ```jsx
   const handleChange = (e) => {
     const { name, value } = e.target;
     setFormData({
       ...formData,
       [name]: value
     });
   };
   ```

   Синтаксис `[name]: value` позволяет динамически обновлять свойство объекта по имени поля.

5. Создайте функцию валидации:

   ```jsx
   const validate = () => {
     const newErrors = {};
     if (!formData.name.trim()) newErrors.name = 'Имя обязательно';
     if (!formData.email.includes('@')) newErrors.email = 'Некорректный email';
     if (formData.password.length < 6) newErrors.password = 'Пароль должен быть не короче 6 символов';
     setErrors(newErrors);
     return Object.keys(newErrors).length === 0;
   };
   ```

6. Создайте обработчик отправки формы:

   ```jsx
   const handleSubmit = (e) => {
     e.preventDefault(); // Предотвращает перезагрузку страницы
     if (validate()) {
       alert(`Регистрация успешна!\nДобро пожаловать, ${formData.name}!`);
       // В реальном приложении здесь был бы запрос на сервер
     }
   };
   ```

7. Верните JSX-разметку формы:

   ```jsx
   return (
     <form onSubmit={handleSubmit}>
       <h2>Регистрация</h2>
       <div>
         <label>Имя:</label>
         <input
           type="text"
           name="name"
           value={formData.name}
           onChange={handleChange}
         />
         {errors.name && <span style={{ color: 'red' }}>{errors.name}</span>}
       </div>
       <div>
         <label>Email:</label>
         <input
           type="email"
           name="email"
           value={formData.email}
           onChange={handleChange}
         />
         {errors.email && <span style={{ color: 'red' }}>{errors.email}</span>}
       </div>
       <div>
         <label>Пароль:</label>
         <input
           type="password"
           name="password"
           value={formData.password}
           onChange={handleChange}
         />
         {errors.password && <span style={{ color: 'red' }}>{errors.password}</span>}
       </div>
       <button type="submit">Зарегистрироваться</button>
     </form>
   );
   ```

8. **Подключите компонент к** `**App.js**`**:**

   ```jsx
   import RegistrationForm from './RegistrationForm';
   // ...
   return (
     <div className="App">
       {/* ... ваш To-Do List ... */}
       <RegistrationForm />
     </div>
   );
   ```

9. **Протестируйте:** Заполните форму с ошибками и без. Убедитесь, что ошибки появляются и исчезают корректно.

---

#### **Задача 2: Получение данных с публичного API** 

Цель: научиться использовать `useEffect` для загрузки данных с внешнего API.

1. В папке `src` создайте новый файл `PostList.js`.

2. Импортируйте хуки и создайте компонент:

   ```jsx
   import { useState, useEffect } from 'react';
   // Или, если вы установили axios:
   // import axios from 'axios';
   
   export default function PostList() {
     const [posts, setPosts] = useState([]);
     const [loading, setLoading] = useState(true);
   
     // Эффект для загрузки данных
     useEffect(() => {
       const fetchData = async () => {
         try {
           // Вариант с fetch
           const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5');
           const data = await response.json();
           setPosts(data);
         } catch (error) {
           console.error('Ошибка при загрузке:', error);
         } finally {
           setLoading(false);
         }
       };
   
       fetchData();
     }, []); // Пустой массив зависимостей = выполнить один раз
   
     if (loading) return <p>Загрузка постов...</p>;
   
     return (
       <div>
         <h2>Последние посты</h2>
         <ul>
           {posts.map(post => (
             <li key={post.id}>
               <strong>{post.title}</strong>
               <p>{post.body}</p>
             </li>
           ))}
         </ul>
       </div>
     );
   }
   ```

3. **Подключите компонент к** `**App.js**`**:**

   ```jsx
   import PostList from './PostList';
   // ...
   return (
     <div className="App">
       {/* ... ваш To-Do List и RegistrationForm ... */}
       <PostList />
     </div>
   );
   ```

4. **Протестируйте:** При загрузке страницы вы должны увидеть надпись "Загрузка постов...", которая через мгновение заменится списком из 5 постов с заголовками и текстом. Это и есть работа `useEffect` в действии!

**Преподаватель:** Поздравляю! Вы только что научились создавать сложные формы и интегрировать ваше React-приложение с внешним миром через API. Это огромный шаг вперёд.

## Часть 3: Мини-проект, ДЗ и Заключение 

### 3\.1. Мини-проект: «Поиск картинок через API Unsplash»

**Преподаватель:** Отлично! Теперь, когда вы освоили управляемые формы и работу с API через `useEffect`, давайте соберём всё это в один небольшой, но очень впечатляющий проект -- **поиск изображений**.

Мы будем использовать **публичный API от Unsplash** -- одного из самых популярных фотостоков. Для учебных целей нам не понадобится регистрация, так как Unsplash предоставляет бесплатный доступ к поиску.

**Требования к проекту:**

1. Поле ввода для поискового запроса (управляемое).

2. Кнопка для отправки запроса.

3. Запрос к API Unsplash: `https://api.unsplash.com/search/photos?query=ваш_запрос&client_id=YOUR_ACCESS_KEY`.

4. Отображение найденных изображений в виде сетки.

5. Индикатор загрузки во время выполнения запроса.

**План выполнения в** `**src/ImageSearch.js**`**:**

1. **Подготовка состояния:**

   ```jsx
   const [query, setQuery] = useState('');
   const [images, setImages] = useState([]);
   const [loading, setLoading] = useState(false);
   ```

2. **Функция поиска:**

   ```jsx
   const handleSearch = async (e) => {
     e.preventDefault();
     if (!query.trim()) return;
   
     setLoading(true);
     try {
       // Используем бесплатный ключ для демонстрации
       const response = await fetch(
         `https://api.unsplash.com/search/photos?query=${query}&client_id=V1StGXR8_ZSw7pXr7L4r3Kd5d1nQx5qK8y6v1X7z9c8`
       );
       const data = await response.json();
       setImages(data.results);
     } catch (error) {
       console.error('Ошибка поиска:', error);
     } finally {
       setLoading(false);
     }
   };
   ```

   <note type="quote">

   **Важно:** В реальном проекте ключ API **никогда не должен быть в клиентском коде**. Он должен храниться на сервере. Здесь мы используем его только для демонстрации.

   </note>

3. **Рендеринг:**

   ```jsx
   return (
     <div>
       <h2>Поиск изображений</h2>
       <form onSubmit={handleSearch}>
         <input
           type="text"
           value={query}
           onChange={(e) => setQuery(e.target.value)}
           placeholder="Введите запрос..."
         />
         <button type="submit">Найти</button>
       </form>
   
       {loading && <p>Загрузка изображений...</p>}
   
       <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '10px' }}>
         {images.map(img => (
           <img
             key={img.id}
             src={img.urls.small}
             alt={img.alt_description || 'Изображение'}
             style={{ width: '100%', height: 'auto', borderRadius: '8px' }}
           />
         ))}
       </div>
     </div>
   );
   ```

4. **Подключите компонент к** `**App.js**` и протестируйте. Введите запрос, например, "cats", и вы увидите сетку с изображениями. Это ваше первое приложение, которое взаимодействует с реальным API!

---

### 3\.2. Домашнее задание 

**Преподаватель:** Чтобы закрепить материал и подготовиться к следующему модулю, выполните домашнее задание.

**Задание:** Улучшить мини-проект «Поиск картинок».

**Требования:**

1. **Добавить debounce для поля поиска.**\
   Это означает, что запрос не будет отправляться при каждом нажатии клавиши, а только после паузы ввода (например, 500 мс). Это предотвратит спам запросами.\
   *Подсказка:* Используйте `useEffect` с зависимостью от `query` и `setTimeout`.

2. **Сохранять последние 5 поисковых запросов в** `**localStorage**`**.**\
   При загрузке страницы список последних запросов должен восстанавливаться. Отображайте их под полем ввода как кнопки -- при клике на кнопку должен выполняться поиск по этому запросу.

**Критерии оценки:**

-  **Оценка 5 (Отлично):** Задание выполнено полностью. Debounce и `localStorage` работают корректно, история сохраняется между перезагрузками.

-  **Оценка 4 (Хорошо):** Есть мелкие недочёты (например, debounce работает, но история не обновляется в реальном времени).

-  **Оценка 3 (Удовлетворительно):** Реализована только базовая функциональность без улучшений.

**Срок сдачи:** \[Укажите дату\].

---

### 3\.3. Контрольные вопросы и Заключение 

**Преподаватель:** Давайте подведём итоги и проверим, насколько хорошо вы усвоили материал. Я задам несколько вопросов.

**Контрольные вопросы:**

1. **Когда вызывается хук** `**useEffect**`**?**\
   *Ответ:* После каждого рендера компонента. Если указан массив зависимостей, то -- только при изменении этих зависимостей. Если массив пустой -- один раз при монтировании.

2. **Чем управляемая форма отличается от неуправляемой?**\
   *Ответ:* В управляемой форме значение поля хранится в состоянии React и обновляется через `onChange`. В неуправляемой -- значение хранится в DOM и читается через `ref`.

3. **Как защититься от гонок (race conditions) при отмене запросов в** `**useEffect**`**?**\
   *Ответ:* Использовать `AbortController`. При размонтировании компонента вызывать `abort()`, чтобы отменить незавершённый запрос и избежать ошибок.

**Заключение:**

**Преподаватель:** Сегодня мы сделали огромный шаг вперёд. Мы научились создавать надёжные, валидируемые формы и интегрировать наши React-приложения с внешним миром через API. Благодаря `useEffect`, наши компоненты теперь могут не просто отображать данные, но и активно с ними взаимодействовать.

Это знание -- ключ к созданию **реальных, полезных веб-приложений**. В следующем **Модуле 7** мы наконец-то перейдём на другую сторону -- к **бэкенду**. Мы познакомимся с **Node.js и Express** и научимся создавать собственные серверы и API, чтобы ваши React-приложения могли не только получать, но и **сохранять данные**.

**Спасибо за внимание!** Удачи в выполнении домашнего задания. Помните: каждая строка кода приближает вас к созданию собственного полноценного веб-приложения!